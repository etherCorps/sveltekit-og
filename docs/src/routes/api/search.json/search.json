[{"title":"Getting Started","href":"/docs/getting-started","description":"A quick guide to get started using Sveltekit OG","content":"import { Callout } from \"@svecodocs/kit\";  import { Steps, Step } from \"@svecodocs/kit\";     import NodePackageInstallerTabs from \"$lib/components/add-ons/installer-tabs.svelte\";     import InstallSveltekitOg from \"$lib/components/add-ons/packages/sveltekit-og.md\";  Setup: Installation & Plugin  Setting up SvelteKit OG is a two-step process: installing the core package and adding the necessary plugin to handle wasm file for build.    We strongly suggest using sveltekit-og v4 as older versions are not maintained. Sveltekit OG v4 only supports Svelte v5 (Runes) and later. We are not planning to support Svelte v4.      Installation  Install the package using your preferred package manager:    Plugins Configuration  Sveltekit OG requires a plugin to handle native dependencies (WASM). You must use one of the two options below.  Vite Plugin  This is the preferred method for SvelteKit v4.1.0 onwards. It uses the simpler sveltekitOG function.    The Vite plugin is available from sveltekit-og@v4.1.0. If you are using v4.0.0, you must use the $2 configuration below. If you add the plugin while the dev server is running, please stop and restart the server to ensure the plugin is applied correctly.    import { sveltekit } from '@sveltejs/kit/vite'; import { sveltekitOG } from '@ethercorps/sveltekit-og/plugin'; const config = {  plugins: [sveltekit(), sveltekitOG()] };  export default config;  Rollup Plugin  This plugin is primarily exist because of my own mistake.   The Rollup plugin will be deprecated in v5 of SvelteKit OG. Please migrate to the Vite plugin if possible.    import { sveltekit } from '@sveltejs/kit/vite'; import { rollupWasm } from '@ethercorps/sveltekit-og/plugin'; const config = {  plugins: [sveltekit()],  build: {   rollupOptions: {    plugins: [rollupWasm()]   }  } };  export default config;  Next Steps  Once the package is installed and the plugin is configured, you are ready to create your first dynamic image by defining a SvelteKit server route and returning an ImageResponse. For Svelte Components**: If you prefer building your images using .svelte files, see the $2 guide. For Raw HTML**: If you prefer using pure HTML strings with Tailwind CSS, see the $2 guide."},{"title":"Introduction","href":"/docs/index","description":"What exactly is Sveltekit OG?","content":"import { Callout } from '@svecodocs/kit'   SvelteKit OG is a high-performance utility library designed for server-side image generation within SvelteKit applications.  While its primary use is creating dynamic Open Graph (OG) images for rich social media preview cards, the library is a generic tool capable of converting Svelte components or HTML/CSS into high-quality PNGs, suitable for a wide range of use cases .  It allows you to define a single visual template using modern web technologies and render unique, personalized images on the fly based on dynamic data or URL parameters.  Zero-Browser Rendering  SvelteKit OG achieves its speed and efficiency by relying on two core technologies, entirely avoiding the performance cost of launching a headless browser like Puppeteer:  Satori (Vercel): This engine takes your standard HTML and CSS (Flexbox, Tailwind) and converts it into an SVG representation. Resvg: This powerful Rust-based library then takes the generated SVG and converts it into the final PNG or JPEG image file that is served to the client.  This combination ensures the library runs efficiently in serverless and edge environments (like Vercel Edge, Cloudflare Workers, or Netlify functions).  Key Features & Benefits  ðŸš€ Fast & Lightweight: Unlike Puppeteer or Playwright, sveltekit-og does not launch a browser instance. It runs efficiently in serverless and edge environments (like Vercel Edge or Cloudflare Workers).  ðŸŽ¨ Easy Styling: Style your images using standard CSS (Flexbox) or built-in Tailwind CSS support. If you know how to center a div, you know how to design an OG image.  ðŸ§© Svelte Component Support: You aren't limited to raw HTML strings. You can import and render actual .svelte components inside your image templates.  Typography:   Support for custom fonts and Google Fonts.   Support for Emojis.  ðŸ› ï¸ Developer Experience:   TypeScript Ready: Fully typed for a better development experience.   Debug Mode: Inspect the generated layout bounding boxes to fine-tune your designs."},{"title":"Release","href":"/docs/release","description":"sveltekit-og package release history and latest version.","content":"import ReleasePage from \"$lib/components/add-ons/release.svelte\""},{"title":"Assets Loading","href":"/docs/advanced-usage/local-assets","description":"Guide to handling local images, SVGs, and remote assets in a SvelteKit server environment.","content":"import { Callout, Tabs, TabItem } from \"@svecodocs/kit\";      const exampleTabs = [\"Svelte Component\", \"Raw HTML\"]   When generating OG images, the code runs on the server (Node, Edge, or Worker), not in the browser. This means you cannot use relative paths (e.g., ``) because the image generation engine (Satori) has no access to your client-side assets or file system by default.  To use local assets, you must provide the image data as either a Base64 Data URL or instruct Satori to fetch it via a Public Absolute URL.  Vite Inline Import  This is the recommended method for small, self-contained images (logos, avatars) because it requires no runtime file system access or network requests.  How it Works  The ?inline query suffix is a Vite feature that processes the asset at build time and exports it as a string containing the Base64 Data URL (data:image/png;base64,...). Since this string is available directly in your server-side code, the image generation is highly reliable and fast.  Example           // 1. Import the asset using the ?inline suffix (exports a base64 data URL string)     import myLogoData from '$lib/assets/logo.png?inline';             My Base64 Title           import { ImageResponse } from '@ethercorps/sveltekit-og'; // Import the image directly as a Base64 data URL string import logoDataUrl from '$lib/assets/logo.png?inline';  export const GET = async () => {  const htmlToRender = `                    `;   return new ImageResponse(htmlToRender, { width: 1200, height: 630 }); };  Reading Local Assets  This method is ideal for large assets (e.g., high-resolution background images) or files you need as an ArrayBuffer (like custom fonts), where embedding the file with ?inline is too large.  How it Works  The ?url suffix tells Vite to export the asset's path as a string (e.g., $lib/assets/logo.png). The SvelteKit utility  $app/server/read uses this path to access the asset within the server's build directory and returns the content as a Response. Example  Reading into an ArrayBuffer  import { ImageResponse } from '@ethercorps/sveltekit-og'; // 1. Import the asset path string using ?url import imagePath from '$lib/assets/large_image.jpg?url'; import { read } from '$app/server'; // 2. Import the server read utility  export const GET = async ({ fetch }) => {  // 3. Read the content of the asset path using the utility  const assetResponse = await read(imagePath);  const imageBuffer = await assetResponse.arrayBuffer();   // 4. Convert ArrayBuffer to Base64 for Satori's consumption  const base64Image = Buffer.from(imageBuffer).toString('base64');  const mimeType = assetResponse.headers.get('content-type') || 'image/jpeg';  const dataUrl = data:${mimeType};base64,${base64Image};   const htmlToRender = `                    `;   return new ImageResponse(htmlToRender, { width: 1200, height: 630 }); };  Using Public Absolute Path  This method is the simplest for referencing assets placed in the static folder, but it relies on making an HTTP network request during image generation.  How it Works  Satori's rendering engine requires a full absolute URL (e.g., https://example.com/logo.png) to fetch the image via HTTP. You must construct this URL using the request URL's origin.  Example  import { ImageResponse } from '@ethercorps/sveltekit-og'; import type { RequestHandler } from './$types';  export const GET: RequestHandler = async ({ url }) => {  // Construct the absolute URL using the request URL's origin  // Assumes logo.png is in the static folder  const absoluteUrl = ${url.origin}/logo.png;   const htmlToRender = `                    `;   return new ImageResponse(htmlToRender, { width: 1200, height: 630 }); };  [//]: # () [//]: # ( )  [//]: # (    ) [//]: # (In Edge Runtimes &#40;Cloudflare, Vercel Edge, Deno&#41;, using fetch&#40;&#41; to retrieve an asset from your own server &#40;url.origin&#41; can sometimes slow cold starts.  )  [//]: # (- Method 1 &#40;?inline&#41; or Method 2 &#40;$app/server/read&#41; is strongly preferred in these environments.)  [//]: # ()"},{"title":"Auto-generate OG Images","href":"/docs/examples/auto-generate-routes","description":"Learn how to automatically generate Open Graph images for your content.","content":""},{"title":"GitHub Repository OG Image","href":"/docs/examples/github-repo-og","description":"Recreate the iconic GitHub repository social card using dynamic data and Svelte components.","content":"import { Callout, DemoContainer, Tabs, TabItem } from \"@svecodocs/kit\";     import SvelteComponentPlayground from \"$lib/components/playground/svelte-component.svelte\";     import { page } from \"$app/state\";   const serverFiles = [\"github-repo.svelte\", \"+server.ts\", \"api.ts\", \"fonts-utils.ts\"];     const tabHashMapping = {       \"#the-visual-component\": \"github-repo.svelte\",       \"#the-api-route\": \"+server.ts\",       \"#data-fetching-helper\": \"api.ts\",       \"#fonts-config\": \"fonts-utils.ts\"     };     const currentTab = $derived(page.url.hash ? tabHashMapping[page.url.hash] : '#the-visual-component');  Overview  In this example, we will recreate the iconic GitHub repository Open Graph image. This involves: Fetching live data from the GitHub API. Loading custom fonts (Inter) to match the brand. Rendering a Svelte component that visually mimics the design.  Target Design:  Code Implementation  The Visual Component  Svelte component handles the layout. It receives data via props and uses Tailwind classes (via class attribute) for styling.  The API Route  Server endpoint ties everything together. It handles the request, fetches the data, loads the fonts, and returns the generated image.  Data Fetching Helper  A simple utility to fetch repository details (stars, forks, issues) from the GitHub API.  Fonts Config  To get the authentic look, we load the Inter font family (Regular and Bold) using Google Fonts.  Live Preview  Start your development server and visit the URL below. Change the owner and repo query parameters to generate cards for different repositories instantly in $2.  Playground  Experiment with the component props directly in the browser:"},{"title":"Pre-render OG Images","href":"/docs/examples/pre-render","description":"How to use SvelteKit's pre-rendering Open Graph images for static routes.","content":""},{"title":"Cloudflare","href":"/docs/runtime/cloudflare","description":"How to use Sveltekit OG with cloudflare adapter (@sveltejs/cloudflare-adapter)","content":"import { Callout} from '@svecodocs/kit';     import NodePackageInstallerTabs from \"$lib/components/add-ons/installer-tabs.svelte\";      import InstallCloudflareAdapter from \"$lib/components/add-ons/packages/sveltekit-adapter/cloudflare.md\";    This section details the necessary configuration to ensure the SvelteKit OG's image generation engine, which relies on WebAssembly (Wasm), is correctly bundled and executed within the Cloudflare Workers or Pages runtime environment.  Installation  To deploy with Cloudflare, you must first install the necessary SvelteKit adapter:    In your svelte.config.js, configure the adapter:  import adapter from '@sveltejs/adapter-cloudflare';  const config = {   ...,     kit: {         adapter: adapter()     },     ... }; export default config;  Plugin Configuration  The image generation uses the @resvg/resvg-wasm, satori, yoga, which relies on a Wasm module. The official SvelteKit OG plugins handle the complex Wasm bundling required for the build/runtime. You must choose one of the following plugins based on your sveltekit-og version.  Vite Plugin (Recommended)    Vite plugin is available from sveltekit-og@v4.1.0. If you are using v4.0.0 use $2 plugin.  If you add the plugin while the dev server is running, you might see no generated image. Stop the server and re-start it.    Add the sveltekitOG plugin to your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { sveltekitOG } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [   sveltekit(),   sveltekitOG() // Add the Vite plugin  ] });  export default config;  Rollup Plugin (Legacy)   The Rollup plugin will be deprecated in v5. Migrate to the Vite plugin when possible.   Add the rollupWasm plugin inside the rollupOptions block in your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { rollupWasm } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [sveltekit()],  build: {   rollupOptions: {    // Add rollupWasm plugin for Cloudflare compatibility    plugins: [rollupWasm()]   }  } });  export default config;  Usage  Once configured, the usage remains the same as any other SvelteKit environment.  Svelte Components: Refer to the $2 usage.  Raw HTML: Refer to the $2 for usage with string templates.  Preview  Cloudflare Workers    Source: https://github.com/etherCorps/sveltekit-og/tree/main/examples/cf-workers-build  Live: https://workers.sveltekit-og.dev/cog  Cloudflare Pages    Source: https://github.com/etherCorps/sveltekit-og/tree/main/examples/cf-pages-build  Live: https://pages.sveltekit-og.dev/cog"},{"title":"Deno Deploy","href":"/docs/runtime/deno","description":"How to use Sveltekit OG with the Deno adapter (svelte-adapter-deno)","content":"import { Callout, Collapsible } from '@svecodocs/kit';     import NodePackageInstallerTabs from \"$lib/components/add-ons/installer-tabs.svelte\";      import InstallDenoAdapter from \"$lib/components/add-ons/packages/sveltekit-adapter/deno.md\";    This section details the configuration needed to deploy SvelteKit OG using the Deno adapter (svelte-adapter-deno), targeting the Deno Runtime (Deno Deploy).  Installation  To deploy with deno, you must first install the necessary SvelteKit adapter:    In your svelte.config.js, configure the adapter:  import adapter from 'svelte-adapter-deno';  const config = {   ...,     kit: {         adapter: adapter()     },     ... }; export default config;  Plugin Configuration  The image generation uses the @resvg/resvg-wasm, satori, yoga, which relies on a Wasm module. The official SvelteKit OG plugins handle the complex Wasm bundling required for the build/runtime. You must choose one of the following plugins based on your sveltekit-og version.  Vite Plugin (Recommended)    Vite plugin is available from sveltekit-og@v4.1.0. If you are using v4.0.0 use $2 plugin.  If you add the plugin while the dev server is running, you might see no generated image. Stop the server and re-start it.    Add the sveltekitOG plugin to your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { sveltekitOG } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [   sveltekit(),   sveltekitOG() // Add the Vite plugin  ] });  export default config;  Rollup Plugin (Legacy)   The Rollup plugin will be deprecated in v5. Migrate to the Vite plugin when possible.   Add the rollupWasm plugin inside the rollupOptions block in your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { rollupWasm } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [sveltekit()],  build: {   rollupOptions: {    // Add rollupWasm plugin for Cloudflare compatibility    plugins: [rollupWasm()]   }  } });  export default config;  Usage  Once configured, the usage remains the same as any other SvelteKit environment.  Svelte Components: Refer to the $2 usage.  Raw HTML: Refer to the $2 for usage with string templates.  Preview    Source: https://github.com/etherCorps/sveltekit-og/tree/main/examples/deno-build  Live: https://deno.sveltekit-og.dev/cog  Known Issues    Deno throws error when we use $2  import imagePath from '$lib/assets/JetBrainsMono-Regular.ttf?url';  or  import imagePath from '$lib/assets/JetBrainsMono-Regular.ttf';  Error:  NotFound: No such file or directory (os error 2): open '_app/immutable/assets/JetBrainsMono-Regular.Dh36KTnx.ttf'     at Object.openSync (ext:deno_fs/30_fs.js:543:15)     at read (file:///app/src/.deno-deploy/handler.ts:55:25)     at wrapped_read (file:///app/src/.deno-deploy/server/index.js:4390:24)     at read (file:///app/src/.deno-deploy/server/entries/endpoints/_server.ts.js:142:25)     at CustomFont.weight [as input] (file:///app/src/.deno-deploy/server/entries/endpoints/_server.ts.js:154:42)     at fallback (file:///app/src/.deno-deploy/server/entries/endpoints/_server.ts.js:40:74)     at eventLoopTick (ext:core/01_core.js:179:7)     at async file:///app/src/.deno-deploy/server/entries/endpoints/_server.ts.js:97:24     at async Promise.all (index 0)     at async resolveFonts (file:///app/src/.deno-deploy/server/entries/endpoints/_server.ts.js:96:25)"},{"title":"Netlify","href":"/docs/runtime/netlify","description":"How to use Sveltekit OG with netlify adapter (@sveltejs/adapter-netlify)","content":"import { Callout, Collapsible } from '@svecodocs/kit';     import NodePackageInstallerTabs from \"$lib/components/add-ons/installer-tabs.svelte\";      import InstallNetlifyAdapter from \"$lib/components/add-ons/packages/sveltekit-adapter/netlify.md\";    This section details the configuration needed to use SvelteKit OG with the Netlify Adapter (@sveltejs/adapter-netlify), targeting the Netlify Functions environment (which uses Node.js).  Netlify Functions, similar to Vercel Serverless Functions, are a Node.js-based environment that generally supports the Wasm module dependencies required by the image generation engine. However, the SvelteKit OG plugins ensure the Wasm files are correctly bundled and available within the function context.  Installation  First, ensure you have the Netlify adapter installed:   In your svelte.config.js, configure the adapter:  import adapter from 'svelte-adapter-deno';  const config = {   ...,     kit: {         adapter: adapter()     },     ... }; export default config;  Plugin Configuration  The image generation uses the @resvg/resvg-wasm, satori, yoga, which relies on a Wasm module. The official SvelteKit OG plugins handle the complex Wasm bundling required for the build/runtime. You must choose one of the following plugins based on your sveltekit-og version.  Vite Plugin (Recommended)    Vite plugin is available from sveltekit-og@v4.1.0. If you are using v4.0.0 use $2 plugin.  If you add the plugin while the dev server is running, you might see no generated image. Stop the server and re-start it.    Add the sveltekitOG plugin to your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { sveltekitOG } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [   sveltekit(),   sveltekitOG() // Add the Vite plugin  ] });  export default config;  Rollup Plugin (Legacy)   The Rollup plugin will be deprecated in v5. Migrate to the Vite plugin when possible.   Add the rollupWasm plugin inside the rollupOptions block in your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { rollupWasm } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [sveltekit()],  build: {   rollupOptions: {    // Add rollupWasm plugin for Cloudflare compatibility    plugins: [rollupWasm()]   }  } });  export default config;  Usage  Once configured, the usage remains the same as any other SvelteKit environment.  Svelte Components: Refer to the $2 usage.  Raw HTML: Refer to the $2 for usage with string templates.  Preview    Source: https://github.com/etherCorps/sveltekit-og/tree/main/examples/netlify-build  Live: https://netlify.sveltekit-og.dev/cog  Known Issues    Netlify throws error when we use $2  import imagePath from '$lib/assets/large_image.jpg?url';"},{"title":"Node JS","href":"/docs/runtime/node","description":"How to use Sveltekit OG with the node adapter (@sveltejs/adapter-node)","content":"import { Callout} from '@svecodocs/kit';     import NodePackageInstallerTabs from \"$lib/components/add-ons/installer-tabs.svelte\";      import InstallNodeAdapter from \"$lib/components/add-ons/packages/sveltekit-adapter/node.md\";    This section details the necessary configuration to use SvelteKit OG with the Node Adapter (@sveltejs/adapter-node), targeting a standard self-hosted Node.js server environment.  Installation  First, ensure you have the Node adapter installed:   In your svelte.config.js, configure the adapter:  import adapter from '@sveltejs/adapter-node';  const config = {   ...,     kit: {         adapter: adapter()     },     ... }; export default config;  Plugin Configuration  You must use one of the SvelteKit OG plugins and explicitly set the esmImport option to false. This configuration ensures the Wasm module is loaded using Node's standard functions, providing reliable execution in the Node environment.  Vite Plugin (Recommended)    Vite plugin is available from sveltekit-og@v4.1.0. If you are using v4.0.0 use $2 plugin.  If you add the plugin while the dev server is running, you might see no generated image. Stop the server and re-start it.    Add the sveltekitOG plugin to your vite.config.ts, passing { esmImport: false } to the options.  import { sveltekit } from '@sveltejs/kit/vite'; import { sveltekitOG } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [   sveltekit(),   sveltekitOG({    esmImport: false // Crucial for reliable Wasm loading in Node.js   })  ] });  export default config;  Rollup Plugin (Legacy)    The Rollup plugin will be deprecated in v5. Migrate to the Vite plugin when possible.    If using the Rollup plugin, apply { esmImport: false } directly to the rollupWasm plugin configuration within rollupOptions.  import { sveltekit } from '@sveltejs/kit/vite'; import { rollupWasm } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [sveltekit()],  build: {   rollupOptions: {    plugins: [     rollupWasm({      esmImport: false // Crucial for reliable Wasm loading in Node.js     })    ]   }  } });  export default config;  Usage  Once configured, the usage remains the same as any other SvelteKit environment.  Svelte Components: Refer to the $2 usage.  Raw HTML: Refer to the $2 for usage with string templates.  Preview (Self Test)  Source: https://github.com/etherCorps/sveltekit-og/tree/main/examples/node-build  To verify the Node setup works correctly, you can clone and run the dedicated example repository.  Step-by-Step Guide  Clone the Repository and Navigate:  git clone https://github.com/etherCorps/sveltekit-og.git cd sveltekit-og/examples/node-build  Install Dependencies:  pnpm install  Build the Project**: This command runs the build process, applying the @sveltejs/adapter-node and the Wasm plugins, resulting in a deployable Node server build in the ./build directory.  pnpm run build  Start the preview Server**: This command starts the Node server using the generated output.  pnpm run preview  More on how to use $2"},{"title":"Vercel","href":"/docs/runtime/vercel","description":"How to use Sveltekit OG with the vercel adapter (@sveltejs/adapter-vercel)","content":"import { Callout} from '@svecodocs/kit';     import NodePackageInstallerTabs from \"$lib/components/add-ons/installer-tabs.svelte\";      import InstallVercelAdapter from \"$lib/components/add-ons/packages/sveltekit-adapter/vercel.md\";    This section details the configuration needed to use SvelteKit OG with the Vercel Adapter (@sveltejs/adapter-vercel), targeting the Vercel Edge Runtime or Serverless Functions (Node).  Installation  First, ensure you have the Vercel adapter installed:    In your svelte.config.js, configure the adapter:  import adapter from '@sveltejs/adapter-vercel';  const config = {   ...,     kit: {         adapter: adapter()     },     ... }; export default config;  Plugin Configuration  The image generation uses the @resvg/resvg-wasm, satori, yoga, which relies on a Wasm module. The official SvelteKit OG plugins handle the complex Wasm bundling required for the runtime. You must choose one of the following plugins based on your sveltekit-og version.  Vite Plugin (Recommended)    Vite plugin is available from sveltekit-og@v4.1.0. If you are using v4.0.0 use $2 plugin.  If you add the plugin while the dev server is running, you might see no generated image. Stop the server and re-start it.    Add the sveltekitOG plugin to your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { sveltekitOG } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [   sveltekit(),   sveltekitOG() // Add the Vite plugin  ] });  export default config;  Rollup Plugin (Legacy)   The Rollup plugin will be deprecated in v5. Migrate to the Vite plugin when possible.   Add the rollupWasm plugin inside the rollupOptions block in your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { rollupWasm } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [sveltekit()],  build: {   rollupOptions: {    // Add rollupWasm plugin for Cloudflare compatibility    plugins: [rollupWasm()]   }  } });  export default config;  Edge and Serverless Split  The SvelteKit Vercel adapter supports specifying the runtime on a per-route basis. This is highly recommended to isolate your computationally intensive OG image route into the smaller, faster Edge or Fluid Runtime, while keeping other APIs on the larger, more flexible Serverless (Node) runtime.  You can achieve this by adding a +server.ts configuration file alongside your OG image route.  Edge  This route runs on the Edge Runtime:  // 1. Specify the runtime for this route export const config = {  runtime: 'edge', // Use the Vercel Edge Runtime  split: true // Recommended to ensure isolation };  import { ImageResponse } from '@ethercorps/sveltekit-og'; import type { RequestHandler } from './$types';  export const GET: RequestHandler = async () => {  // Your standard ImageResponse logic here  return new ImageResponse(/* ... */); };    When targeting the Edge Runtime (via export const config = { runtime: 'edge' }), your entire function size, including all dependencies (like the Satori Wasm module and fonts), must be under the 1MB limit. Using many custom fonts or large components can easily exceed this size, resulting in deployment failure.  Serverless (Node) Runtime  // No 'config' export means it defaults to the Node Serverless Function. You can use split config here too. import type { RequestHandler } from './$types'; import { ImageResponse } from '@ethercorps/sveltekit-og';  export const GET: RequestHandler = async () => {  return new ImageResponse(/* ... */); };  Usage  Once configured, the usage remains the same as any other SvelteKit environment.  Svelte Components: Refer to the $2 usage.  Raw HTML: Refer to the $2 for usage with string templates.  Preview    Source: https://github.com/etherCorps/sveltekit-og/tree/main/examples/vercel-build  Live: https://vercel.sveltekit-og.dev/sc"},{"title":"Raw HTML","href":"/docs/usage/html","description":"How to use raw HTML strings to generate images","content":"import { Callout } from \"@svecodocs/kit\";  Overview  Sometimes you might prefer using standard HTML files over Svelte componentsâ€”perhaps for performance, portability, or to decouple the design from the framework.  Prerequisites  Ensure, Vite/Rollup Plugin configuration as described in the $2.  Guide  This guide shows the most basic functionality: rendering a static image directly from an HTML string, without Svelte components.  HTML Template  Define the HTML string directly in +server.ts file. Remember to use inline styles or utility classes, as the image renderer does not process external CSS files.  const htmlString = `   @ethercorps/sveltekit-og  Your Raw HTML Open Graph Image!  `;  API Route  The key difference here is that you pass the string as the first argument to ImageResponse. The third argument (for Svelte component props) is not used.  // Auto added by remark-code-import  Preview  Visit the URL corresponding to route in browser (e.g. http://localhost:5173/images/raw-html.png).  Next Steps  Dynamic Data: To inject dynamic data (e.g., a post title) into your HTML string, you will need to use JavaScript string replacement or a dedicated **templating engine before passing the string to ImageResponse. Types Reference**: For a full overview of all options and parameters for ImageResponse, see $2 reference guide. Local Assets**: To include local images or other assets in OG images, see $2 guide. Custom Fonts**: To use fonts other than the default, see $2 guide for detailed instructions."},{"title":"Svelte Component","href":"/docs/usage/svelte","description":"The simplest guide to generating your first static OG image using svelte component.","content":"import { Callout, DemoContainer } from '@svecodocs/kit';     import SvelteComponentPlayground from '$lib/components/playground/svelte-component.svelte';  Prerequisites  Ensure, Vite/Rollup Plugin configuration as described in the $2.  Guide  We will create the simplest possible Open Graph image. This example uses a Svelte component without any dynamic data fetching or complex logic.  Create your Component  Component should use standard HTML and CSS (or utility classes from Tailwind CSS). Ensure the component's root element has a style of width: 100% and height: 100% to correctly fill the rendering area defined in the options.    If using style blocks, you must enable CSS injection in svelte options.      // Auto added from source file  Create API route  Create a SvelteKit server route (a +server.ts file) and use the ImageResponse constructor to render your component. For this basic setup, we include only the mandatory configuration: the component, dimensions, and necessary fonts.   // Auto added from source file  Preview  Visit the URL corresponding to route in browser (e.g. http://localhost:5173/images/simple.png).  Using Vanilla CSS  The examples above use Style attribute. However, you can also use standard CSS within Svelte Component `` block or use Tailwind CSS.    If using style blocks, you must enable CSS injection in svelte options.         // component props     Hello World     .card {   display: flex;   background-color: white;   height: 100%;   align-items: center;   justify-content: center;  }  h1 {   font-size: 60px;   color: black;  }  Next Steps  Types Reference**: For a full overview of all options and parameters for ImageResponse, see $2 reference guide. Local Assets**: To include local images or other assets in OG images, see $2 guide. Custom Fonts**: To use fonts other than the default, see $2 guide for detailed instructions."},{"title":"Fonts","href":"/docs/utilities/fonts","description":"How to use self hosted, custom and google fonts with sveltekit-og.","content":"import { Callout } from \"@svecodocs/kit\";     The GoogleFont, CustomFont, and resolveFonts utilities were introduced in  sveltekit-og@v4.2.0.    To ensure consistent and high-quality typography in your generated images, you must provide the font files to the rendering engine (Satori) as raw binary data. You cannot rely on standard CSS @font-face rules.  The SvelteKit OG provides CustomFont, and GoogleFont classes, along with the resolveFonts utility, to handle loading, caching, and preparing the font data.    The ImageResponse options expects an array of resolved font data. You must always pass your font instances to await resolveFonts([...]) before passing the result to the fonts option.  ðŸŒ Using Google Fonts  The GoogleFont class is the easiest way to get started. It abstracts away the network logic, fetches the correct CSS, parses the font URL, and applies an internal cache to prevent redundant requests.  import { ImageResponse } from '@ethercorps/sveltekit-og'; import { GoogleFont, resolveFonts } from '@ethercorps/sveltekit-og/fonts';  // 1. Define the GoogleFont instances const interRegular = new GoogleFont('Inter', {  weight: 400,  name: 'Inter', });  const interBold = new GoogleFont('Inter', {  weight: 700 });  export const GET = async () => {  // 2. Await the resolution (which triggers the fetch/cache lookup)  const resolvedFontOptions = await resolveFonts([interRegular, interBold]);   return new ImageResponse(   Hello World,   {    fonts: resolvedFontOptions   }  ); };  ðŸ“‚ Using Local Custom Fonts  This method involves placing TrueType (.ttf) or OpenType (.otf) files in the project and reading them directly from the file system.  Steps Import: Use the Vite ?url suffix to get the build-time path of your local font file. Load: Use SvelteKit's $app/server read function to retrieve the file. Wrap: Pass a function that returns the ArrayBuffer to CustomFont.    Vite's ?url import combined with read may encounter issues on specific adapters like Netlify. In those cases, you may need to use Node's fs module or fetch the font from a public URL.    import { ImageResponse } from '@ethercorps/sveltekit-og'; import { CustomFont, resolveFonts } from '@ethercorps/sveltekit-og/fonts'; import { read } from '$app/server'; // SvelteKit Runtime Dependency import RegularFontPath from '$lib/assets/MyFont-Regular.ttf?url'; import BoldFontPath from '$lib/assets/MyFont-Bold.ttf?url';  // 1. Define the CustomFont instances const myCustomRegular = new CustomFont(  'My Custom Font',  // The input function executes read().arrayBuffer() only when needed (lazy-loaded)  () => read(RegularFontPath).arrayBuffer(),  { weight: 400 } );  const myCustomBold = new CustomFont(  'My Custom Font',  () => read(BoldFontPath).arrayBuffer(),  { weight: 700 } );  export const GET = async () => {  // 2. Resolve the promises to get the final ArrayBuffer array  const resolvedFontOptions = await resolveFonts([myCustomRegular, myCustomBold]);   return new ImageResponse(   Hello World,   {    width: 1200,    height: 630,    fonts: resolvedFontOptions   }  ); };  â˜ï¸ Using Remote Fonts  If font file is hosted on an external CDN (e.g., AWS S3, generic file host), fetch it directly using the global fetch API.  import { ImageResponse } from '@ethercorps/sveltekit-og'; import { CustomFont, resolveFonts } from '@ethercorps/sveltekit-og/fonts';  const REMOTE_FONT_URL = 'https://my-cdn.com/assets/FontAwesome-Regular.otf';  // 1. Define the CustomFont instance const fontAwesome = new CustomFont(  'Font Awesome',  // Pass a function that returns the ArrayBuffer promise via fetch  () => fetch(REMOTE_FONT_URL).then((res) => res.arrayBuffer()),  { weight: 400 } );  export const GET = async () => {  const resolvedFontOptions = await resolveFonts([fontAwesome]);   return new ImageResponse(   Icon,   {    fonts: resolvedFontOptions   }  ); };  ðŸ”¢ Multiple Font Sources  Mix and match multiple font sources local fonts, Google Fonts, and remote fonts URLs in a single request.  import { ImageResponse } from '@ethercorps/sveltekit-og'; import { CustomFont, GoogleFont, resolveFonts } from '@ethercorps/sveltekit-og/fonts'; import { read } from '$app/server';  // --- Local Font Paths --- import LocalRegularPath from '$lib/assets/LocalFont-R.ttf?url';  // --- Custom Remote URL --- const ICON_FONT_URL = 'https://cdn.example.com/icons.ttf';  export const GET = async () => {  // 1. Define all font instances  const fontsToLoad = [   // A. ðŸ“¦ LOCAL CUSTOM FONT   new CustomFont('Local App Font', () => read(LocalRegularPath).arrayBuffer(), { weight: 400 }),    // B. ðŸŒ GOOGLE FONT   new GoogleFont('Roboto Mono', { weight: 500 }),    // C. â˜ï¸ REMOTE FONT   new CustomFont('Custom Icons', () => fetch(ICON_FONT_URL).then((res) => res.arrayBuffer()), {    weight: 400   })  ];   // 2. Resolve all concurrently  const resolvedFontOptions = await resolveFonts(fontsToLoad);   // 3. Render  return new ImageResponse(   `             Title             Code             Icon         `,   {    width: 1200,    height: 630,    fonts: resolvedFontOptions   }  ); }; `"},{"title":"ImageResponse API Reference","href":"/docs/utilities/types","description":"Reference for the ImageResponse constructor and its options.","content":"import {Callout, PropField, Collapsible, blockquote} from '@svecodocs/kit';  ImageResponse  The ImageResponse class is the central API for generating and serving dynamic images. It extends the standard Web API Response and is designed to be returned directly from a SvelteKit server route (+server.ts).  The constructor takes the component/HTML template, rendering options, and component props.  new ImageResponse>(  element: T,  options?: ImageResponseOptions,  props?: T extends Component ? ComponentProps : never ): Response;  ImageResponse Parameters  To create your dynamic Open Graph image, the ImageResponse constructor needs just three pieces of information, passed in this specific order. Think of this as defining the design, the settings, and the data for your image. Svelte Component or Raw HTML: The design of your imageâ€”what people will actually see. Options: The settings that define the image's size, fonts, and response headers. Props: The dynamic data (like a blog post title) to feed into your Svelte component.  import { ImageResponse } from '@ethercorps/sveltekit-og'; import { CustomFont, resolveFonts } from '@ethercorps/sveltekit-og/fonts'; import MySvelteComponent from '$lib/og/MySvelteComponent.svelte'; export const GET = async () => {     const props = {         title: 'Dynamic Title',         subtitle: 'Generated with Sveltekit OG'     };  const fonts = [   new CustomFont('Inter', () => fetch('https://example.com/fonts/Inter-Regular.ttf').then(res => res.arrayBuffer()), {weight: '400'})     ]      return new ImageResponse(   // 1. Svelte Component or Raw HTML          MySvelteComponent,         // 2. Options         {             width: 1200,             height: 630,             fonts: await resolveFonts(fonts)         },         // 3. Svelte Component props         props     ); };    Font files must be loaded as raw binary data (ArrayBuffer). The GoogleFont, CustomFont and resolveFonts $2 are provided to help you asynchronously load your custom fonts correctly before the image is generated.  Svelte Component or HTML  This parameter defines the visual content of your Open Graph image. You can provide either a Svelte component or a raw HTML string.          While you can use raw HTML, using a Svelte component is recommended for better maintainability and reusability.  ImageResponse Options The options object allows you to customize various technical aspects of the generated image and its HTTP response.       Configuration options for the generated image and its response.                        Sets the width of the final OG image in pixels.                             Sets the height of the final OG image in pixels.                              The file format for the generated image. PNG is standard for OG images, but SVG is also available.                               A list of font definitions (name, data, weight) used to render text in your design.                                                   The font file data loaded as a Buffer or ArrayBuffer.                                                       The font family name (must match your CSS font-family).                                                       The weight of the font (e.g., 400 for regular, 700 for bold).                                                       The style of the font.                                                       The language subset for the font (e.g., 'en').                                                             Choose the style of emojis you want to use in your design (e.g., Twitter's Twemoji is the default).                               Turn this on to show helpful layout guides and rulers on the image. Great for troubleshooting positioning!                               The HTTP status code sent with the image (e.g., 200 for success).                               The HTTP status text sent alongside the status code.                  \" >             Add any custom HTTP headers you need for the response.                                        We automatically add Content-Type based on the image format and Cache-Control for caching. If debug mode is enabled, the Cache-Control header is updated to no-cache.  Component Props  \" >     An object containing the dynamic data to be passed to your Svelte component (the first parameter). If your component expects a title or author, you pass it here!                   This parameter is required if you use a Svelte component that expects props.  The types for this object are automatically inferred from the props defined in your Svelte component.  All Options Example  Here is an example demonstrating how to use several optional parameters, including setting custom headers and enabling debug mode.  import { ImageResponse } from '@ethercorps/sveltekit-og'; import { resolveFonts } from '@ethercorps/sveltekit-og/fonts'; import MySvelteComponent from '$lib/og/MySvelteComponent.svelte'; import { FONT_DATA } from '$lib/fonts'; // Assume pre-loaded font data  export const GET = async ({ url }) => {     // 1. Prepare dynamic data     const isError = url.searchParams.has('error');          // 2. Define custom options     const options = {         width: 1200,         height: 630,         debug: url.searchParams.has('debug'), // Toggle debug mode via query param         emoji: 'blobmoji', // Use a different emoji set         fonts: await resolveFonts(FONT_DATA),                  // 3. Conditional HTTP Response options         status: isError ? 404 : 200,         statusText: isError ? 'Not Found' : 'OK',         headers: {             // Override or add custom headers             'X-OG-Generator': '@ethercorps/sveltekit-og',         }     };          // 4. Define component props     const props = {         title: isError ? 'Page Not Found' : 'Standard Post Title',     };      return new ImageResponse(MySvelteComponent, options, props); };        resolveFonts can only be used with GoogleFont and CustomFont instances."}]