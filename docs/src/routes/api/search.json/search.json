[{"title":"Getting Started","href":"/docs/getting-started","description":"A quick guide to get started using Sveltekit OG","content":"import { Callout } from \"@svecodocs/kit\";  import { Steps, Step } from \"@svecodocs/kit\";     import NodePackageInstallerTabs from \"$lib/components/add-ons/installer-tabs.svelte\";     import InstallSveltekitOg from \"$lib/components/add-ons/packages/sveltekit-og.md\";  Setup  Setting up SvelteKit OG is a two-step process: install the package and plugin.    Installation  Install the package using your preferred package manager:   Plugins  Sveltekit OG provides two plugins (use one of them)  $2 - Available from v4.1.x $2 - Available for v4.x.x - will be deprecated in v5.  Vite  Add vite plugin to vite.config.ts.   Vite plugin is available from sveltekit-og@v4.1.0. If you are using v4.0.0 use Rollup  If you add plugin while dev server is running, you might see no generated image, so stop the server and re-start it.    import { sveltekit } from '@sveltejs/kit/vite'; import { sveltekitOG } from '@ethercorps/sveltekit-og/plugin'; const config = {  plugins: [sveltekit(), sveltekitOG()] };  export default config;  Rollup  Add rollup plugin to vite.config.ts.   Rollup plugin is available from sveltekit-og@v4    Rollup plugin will be deprecated in v5   import { sveltekit } from '@sveltejs/kit/vite'; import { rollupWasm } from '@ethercorps/sveltekit-og/plugin'; const config = {  plugins: [sveltekit()],  build: {   rollupOptions: {    plugins: [rollupWasm()]   }  } };  export default config;         We suggest you to use sveltekit-og v4, as older versions are not maintained and developed.     v4 only supports Svelte v5. We are not planning to support Svelte v4 onwards.  Basic Usage  SvelteKit OG works by returning an ImageResponse from a standard SvelteKit server route.  Create a new file at src/routes/og/+server.ts.  Raw HTML string  Creating images with html and css.  import { ImageResponse } from '@ethercorps/sveltekit-og'; import type { RequestHandler } from './$types';  export const GET: RequestHandler = async () => {  // 1. Define your HTML template  // You can use the 'tw' attribute for Tailwind classes  const html = `                     Hello SvelteKit OG!         Dynamic images made easy               `;   // 2. Return the ImageResponse  return new ImageResponse(html, {   width: 1200,   height: 630   // The library uses 'Noto Sans' by default if no fonts are provided  }); };  Preview  Svelte Components  We can create images with svelte components too.     Always add svelte options on top of the component. It will include the generated styles from style tag.      Svelte Component      import Logo from './logo.png?inline';  import SvelteLogo from './svelte-logo.svg?raw';           @ethercorps/sveltekit-og           SVELTEKIT OG    VERSION 4 âœ¨         Sveltekit OG v4 with support for Node, Deno, Cloudflare Workers, Pages, Vercel and Netlify              {@html SvelteLogo}       sveltekit-og.dev     .bg-gradient {   background: linear-gradient(    to right,    #2c5364,    #203a43,    #0f2027   ); /* W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */  }   og/+server.ts  import type { RequestHandler } from '@sveltejs/kit'; import { ImageResponse } from '@ethercorps/sveltekit-og'; import OG from './OG.svelte';  export const GET: RequestHandler = async () => {  return new ImageResponse(OG, {   width: 1200,   height: 630,   debug: false  }); };  Preview"},{"title":"Introduction","href":"/docs/index","description":"What exactly is Sveltekit OG?","content":"import { Callout } from '@svecodocs/kit'   SvelteKit OG is a utility library for generating dynamic Open Graph (OG) images within SvelteKit applications.  Social media platforms (like Twitter, Facebook, and LinkedIn) rely on Open Graph tags to display preview cards when links are shared. SvelteKit OG allows you to define these images using standard HTML/CSS or Svelte components, and renders them into static PNGs on the fly.  It is powered by Satori (Vercel's engine for converting HTML/CSS to SVG) and Resvg (for SVG to PNG conversion). This combination allows for high-performance image generation without the overhead of a headless browser.  Features  ðŸš€ Fast & Lightweight: Unlike Puppeteer or Playwright, sveltekit-og does not launch a browser instance. It runs efficiently in serverless and edge environments (like Vercel Edge or Cloudflare Workers).  ðŸŽ¨ Easy Styling: Style your images using standard CSS (Flexbox) or built-in Tailwind CSS support. If you know how to center a div, you know how to design an OG image.  ðŸ§© Svelte Component Support: You aren't limited to raw HTML strings. You can import and render actual .svelte components inside your image templates.  Typography:   Support for custom fonts and Google Fonts.   Support for Emojis.  ðŸ› ï¸ Developer Experience:   TypeScript Ready: Fully typed for a better development experience.   Debug Mode: Inspect the generated layout bounding boxes to fine-tune your designs."},{"title":"Release","href":"/docs/release","description":"sveltekit-og package release history and latest version.","content":"import ReleasePage from \"$lib/components/add-ons/release.svelte\""},{"title":"Cloudflare","href":"/docs/runtime/cloudflare","description":"How to use Sveltekit OG with cloudflare adapter (@sveltejs/cloudflare-adapter)","content":"import { Callout} from '@svecodocs/kit';     import NodePackageInstallerTabs from \"$lib/components/add-ons/installer-tabs.svelte\";      import InstallCloudflareAdapter from \"$lib/components/add-ons/packages/sveltekit-adapter/cloudflare.md\";    This section details the necessary configuration to ensure the SvelteKit OG's image generation engine, which relies on WebAssembly (Wasm), is correctly bundled and executed within the Cloudflare Workers or Pages runtime environment.  Installation  To deploy with Cloudflare, you must first install the necessary SvelteKit adapter:    In your svelte.config.js, configure the adapter:  import adapter from '@sveltejs/adapter-cloudflare';  const config = {   ...,     kit: {         adapter: adapter()     },     ... }; export default config;  Plugin Configuration  The image generation uses the @resvg/resvg-wasm, satori, yoga, which relies on a Wasm module. The official SvelteKit OG plugins handle the complex Wasm bundling required for the build/runtime. You must choose one of the following plugins based on your sveltekit-og version.  Vite Plugin (Recommended)    Vite plugin is available from sveltekit-og@v4.1.0. If you are using v4.0.0 use $2 plugin.  If you add the plugin while the dev server is running, you might see no generated image. Stop the server and re-start it.    Add the sveltekitOG plugin to your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { sveltekitOG } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [   sveltekit(),   sveltekitOG() // Add the Vite plugin  ] });  export default config;  Rollup Plugin (Legacy)   The Rollup plugin will be deprecated in v5. Migrate to the Vite plugin when possible.   Add the rollupWasm plugin inside the rollupOptions block in your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { rollupWasm } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [sveltekit()],  build: {   rollupOptions: {    // Add rollupWasm plugin for Cloudflare compatibility    plugins: [rollupWasm()]   }  } });  export default config;  Usage  Once configured, the usage remains the same as any other SvelteKit environment.  Svelte Components: Refer to the $2 usage.  Raw HTML: Refer to the $2 for usage with string templates.  Preview  Cloudflare Workers    Source: https://github.com/etherCorps/sveltekit-og/tree/main/examples/cf-workers-build  Live: https://workers.sveltekit-og.dev/cog  Cloudflare Pages    Source: https://github.com/etherCorps/sveltekit-og/tree/main/examples/cf-pages-build  Live: https://pages.sveltekit-og.dev/cog"},{"title":"Deno Deploy","href":"/docs/runtime/deno","description":"How to use Sveltekit OG with the Deno adapter (svelte-adapter-deno)","content":"import { Callout} from '@svecodocs/kit';     import NodePackageInstallerTabs from \"$lib/components/add-ons/installer-tabs.svelte\";      import InstallDenoAdapter from \"$lib/components/add-ons/packages/sveltekit-adapter/deno.md\";    This section details the configuration needed to deploy SvelteKit OG using the Deno adapter (svelte-adapter-deno), targeting the Deno Runtime (Deno Deploy).  Installation  To deploy with deno, you must first install the necessary SvelteKit adapter:    In your svelte.config.js, configure the adapter:  import adapter from 'svelte-adapter-deno';  const config = {   ...,     kit: {         adapter: adapter()     },     ... }; export default config;  Plugin Configuration  The image generation uses the @resvg/resvg-wasm, satori, yoga, which relies on a Wasm module. The official SvelteKit OG plugins handle the complex Wasm bundling required for the build/runtime. You must choose one of the following plugins based on your sveltekit-og version.  Vite Plugin (Recommended)    Vite plugin is available from sveltekit-og@v4.1.0. If you are using v4.0.0 use $2 plugin.  If you add the plugin while the dev server is running, you might see no generated image. Stop the server and re-start it.    Add the sveltekitOG plugin to your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { sveltekitOG } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [   sveltekit(),   sveltekitOG() // Add the Vite plugin  ] });  export default config;  Rollup Plugin (Legacy)   The Rollup plugin will be deprecated in v5. Migrate to the Vite plugin when possible.   Add the rollupWasm plugin inside the rollupOptions block in your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { rollupWasm } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [sveltekit()],  build: {   rollupOptions: {    // Add rollupWasm plugin for Cloudflare compatibility    plugins: [rollupWasm()]   }  } });  export default config;  Usage  Once configured, the usage remains the same as any other SvelteKit environment.  Svelte Components: Refer to the $2 usage.  Raw HTML: Refer to the $2 for usage with string templates.  Preview    Source: https://github.com/etherCorps/sveltekit-og/tree/main/examples/deno-build  Live: https://deno.sveltekit-og.dev/cog"},{"title":"Netlify","href":"/docs/runtime/netlify","description":"How to use Sveltekit OG with netlify adapter (@sveltejs/adapter-netlify)","content":"import { Callout, Collapsible } from '@svecodocs/kit';     import NodePackageInstallerTabs from \"$lib/components/add-ons/installer-tabs.svelte\";      import InstallNetlifyAdapter from \"$lib/components/add-ons/packages/sveltekit-adapter/netlify.md\";    This section details the configuration needed to use SvelteKit OG with the Netlify Adapter (@sveltejs/adapter-netlify), targeting the Netlify Functions environment (which uses Node.js).  Netlify Functions, similar to Vercel Serverless Functions, are a Node.js-based environment that generally supports the Wasm module dependencies required by the image generation engine. However, the SvelteKit OG plugins ensure the Wasm files are correctly bundled and available within the function context.  Installation  First, ensure you have the Netlify adapter installed:   In your svelte.config.js, configure the adapter:  import adapter from 'svelte-adapter-deno';  const config = {   ...,     kit: {         adapter: adapter()     },     ... }; export default config;  Plugin Configuration  The image generation uses the @resvg/resvg-wasm, satori, yoga, which relies on a Wasm module. The official SvelteKit OG plugins handle the complex Wasm bundling required for the build/runtime. You must choose one of the following plugins based on your sveltekit-og version.  Vite Plugin (Recommended)    Vite plugin is available from sveltekit-og@v4.1.0. If you are using v4.0.0 use $2 plugin.  If you add the plugin while the dev server is running, you might see no generated image. Stop the server and re-start it.    Add the sveltekitOG plugin to your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { sveltekitOG } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [   sveltekit(),   sveltekitOG() // Add the Vite plugin  ] });  export default config;  Rollup Plugin (Legacy)   The Rollup plugin will be deprecated in v5. Migrate to the Vite plugin when possible.   Add the rollupWasm plugin inside the rollupOptions block in your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { rollupWasm } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [sveltekit()],  build: {   rollupOptions: {    // Add rollupWasm plugin for Cloudflare compatibility    plugins: [rollupWasm()]   }  } });  export default config;  Usage  Once configured, the usage remains the same as any other SvelteKit environment.  Svelte Components: Refer to the $2 usage.  Raw HTML: Refer to the $2 for usage with string templates.  Preview    Source: https://github.com/etherCorps/sveltekit-og/tree/main/examples/netlify-build  Live: https://netlify.sveltekit-og.dev/cog  Known Issues    Netlify throws error when we use $2  import imagePath from '$lib/assets/large_image.jpg?url';"},{"title":"Node JS","href":"/docs/runtime/node","description":"How to use Sveltekit OG with the node adapter (@sveltejs/adapter-node)","content":"import { Callout} from '@svecodocs/kit';     import NodePackageInstallerTabs from \"$lib/components/add-ons/installer-tabs.svelte\";      import InstallNodeAdapter from \"$lib/components/add-ons/packages/sveltekit-adapter/node.md\";    This section details the necessary configuration to use SvelteKit OG with the Node Adapter (@sveltejs/adapter-node), targeting a standard self-hosted Node.js server environment.  Installation  First, ensure you have the Node adapter installed:   In your svelte.config.js, configure the adapter:  import adapter from '@sveltejs/adapter-node';  const config = {   ...,     kit: {         adapter: adapter()     },     ... }; export default config;  Plugin Configuration  You must use one of the SvelteKit OG plugins and explicitly set the esmImport option to false. This configuration ensures the Wasm module is loaded using Node's standard functions, providing reliable execution in the Node environment.  Vite Plugin (Recommended)    Vite plugin is available from sveltekit-og@v4.1.0. If you are using v4.0.0 use $2 plugin.  If you add the plugin while the dev server is running, you might see no generated image. Stop the server and re-start it.    Add the sveltekitOG plugin to your vite.config.ts, passing { esmImport: false } to the options.  import { sveltekit } from '@sveltejs/kit/vite'; import { sveltekitOG } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [   sveltekit(),   sveltekitOG({    esmImport: false // Crucial for reliable Wasm loading in Node.js   })  ] });  export default config;  Rollup Plugin (Legacy)    The Rollup plugin will be deprecated in v5. Migrate to the Vite plugin when possible.    If using the Rollup plugin, apply { esmImport: false } directly to the rollupWasm plugin configuration within rollupOptions.  import { sveltekit } from '@sveltejs/kit/vite'; import { rollupWasm } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [sveltekit()],  build: {   rollupOptions: {    plugins: [     rollupWasm({      esmImport: false // Crucial for reliable Wasm loading in Node.js     })    ]   }  } });  export default config;  Usage  Once configured, the usage remains the same as any other SvelteKit environment.  Svelte Components: Refer to the $2 usage.  Raw HTML: Refer to the $2 for usage with string templates.  Preview (Self Test)  Source: https://github.com/etherCorps/sveltekit-og/tree/main/examples/node-build  To verify the Node setup works correctly, you can clone and run the dedicated example repository.  Step-by-Step Guide  Clone the Repository and Navigate:  git clone https://github.com/etherCorps/sveltekit-og.git cd sveltekit-og/examples/node-build  Install Dependencies:  pnpm install  Build the Project**: This command runs the build process, applying the @sveltejs/adapter-node and the Wasm plugins, resulting in a deployable Node server build in the ./build directory.  pnpm run build  Start the preview Server**: This command starts the Node server using the generated output.  pnpm run preview  More on how to use $2"},{"title":"Vercel","href":"/docs/runtime/vercel","description":"How to use Sveltekit OG with the vercel adapter (@sveltejs/adapter-vercel)","content":"import { Callout} from '@svecodocs/kit';     import NodePackageInstallerTabs from \"$lib/components/add-ons/installer-tabs.svelte\";      import InstallVercelAdapter from \"$lib/components/add-ons/packages/sveltekit-adapter/vercel.md\";    This section details the configuration needed to use SvelteKit OG with the Vercel Adapter (@sveltejs/adapter-vercel), targeting the Vercel Edge Runtime or Serverless Functions (Node).  Installation  First, ensure you have the Vercel adapter installed:    In your svelte.config.js, configure the adapter:  import adapter from '@sveltejs/adapter-vercel';  const config = {   ...,     kit: {         adapter: adapter()     },     ... }; export default config;  Plugin Configuration  The image generation uses the @resvg/resvg-wasm, satori, yoga, which relies on a Wasm module. The official SvelteKit OG plugins handle the complex Wasm bundling required for the runtime. You must choose one of the following plugins based on your sveltekit-og version.  Vite Plugin (Recommended)    Vite plugin is available from sveltekit-og@v4.1.0. If you are using v4.0.0 use $2 plugin.  If you add the plugin while the dev server is running, you might see no generated image. Stop the server and re-start it.    Add the sveltekitOG plugin to your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { sveltekitOG } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [   sveltekit(),   sveltekitOG() // Add the Vite plugin  ] });  export default config;  Rollup Plugin (Legacy)   The Rollup plugin will be deprecated in v5. Migrate to the Vite plugin when possible.   Add the rollupWasm plugin inside the rollupOptions block in your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { rollupWasm } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [sveltekit()],  build: {   rollupOptions: {    // Add rollupWasm plugin for Cloudflare compatibility    plugins: [rollupWasm()]   }  } });  export default config;  Edge and Serverless Split  The SvelteKit Vercel adapter supports specifying the runtime on a per-route basis. This is highly recommended to isolate your computationally intensive OG image route into the smaller, faster Edge or Fluid Runtime, while keeping other APIs on the larger, more flexible Serverless (Node) runtime.  You can achieve this by adding a +server.ts configuration file alongside your OG image route.  Edge  This route runs on the Edge Runtime:  // 1. Specify the runtime for this route export const config = {  runtime: 'edge', // Use the Vercel Edge Runtime  split: true // Recommended to ensure isolation };  import { ImageResponse } from '@ethercorps/sveltekit-og'; import type { RequestHandler } from './$types';  export const GET: RequestHandler = async () => {  // Your standard ImageResponse logic here  return new ImageResponse(/* ... */); };    When targeting the Edge Runtime (via export const config = { runtime: 'edge' }), your entire function size, including all dependencies (like the Satori Wasm module and fonts), must be under the 1MB limit. Using many custom fonts or large components can easily exceed this size, resulting in deployment failure.  Serverless (Node) Runtime  // No 'config' export means it defaults to the Node Serverless Function. You can use split config here too. import type { RequestHandler } from './$types'; import { ImageResponse } from '@ethercorps/sveltekit-og';  export const GET: RequestHandler = async () => {  return new ImageResponse(/* ... */); };  Usage  Once configured, the usage remains the same as any other SvelteKit environment.  Svelte Components: Refer to the $2 usage.  Raw HTML: Refer to the $2 for usage with string templates.  Preview    Source: https://github.com/etherCorps/sveltekit-og/tree/main/examples/vercel-build  Live: https://vercel.sveltekit-og.dev/sc"},{"title":"Fonts","href":"/docs/utilities/fonts","description":"How to use self hosted, custom and google fonts with sveltekit-og.","content":"import { Callout } from \"@svecodocs/kit\";     The GoogleFont, CustomFont, and resolveFonts utilities have been introduced in sveltekit-og@v4.2.0.    To ensure consistent and high-quality typography in your generated images, you must provide the font files to the rendering engine (Satori) as raw binary data. You cannot rely on standard CSS @font-face rules.  The SvelteKit OG library provides the CustomFont, and GoogleFont classes, along with the resolveFonts utility, to handle loading, caching, and preparing the font data.  ðŸ“‚ Using Local Custom Fonts  This method involves placing your TrueType (.ttf) or OpenType (.otf) files in the static or a private asset folder and reading them directly from the file system using SvelteKit's built-in $app/server/read utility.  Example  Import: Use the Vite ?url suffix to get the build-time path of your local font file.    Vite ?url import is not working in netlify deployment.    Load**: Use $app/server/read to retrieve the file as an ArrayBuffer. Wrap: Pass a **function that performs the reading into the CustomFont.  import { ImageResponse, CustomFont, resolveFonts } from '@ethercorps/sveltekit-og'; import { read } from '$app/server'; // SvelteKit Runtime Dependency import RegularFontPath from '$lib/assets/MyFont-Regular.ttf?url'; import BoldFontPath from '$lib/assets/MyFont-Bold.ttf?url';  // 1. Define the CustomFont instances const myCustomRegular = new CustomFont(  'My Custom Font',  // The input function executes read().arrayBuffer() only when needed (lazy-loaded)  () => read(RegularFontPath).arrayBuffer(),  { weight: 400 } );  const myCustomBold = new CustomFont('My Custom Font', () => read(BoldFontPath).arrayBuffer(), {  weight: 700 });  export const GET = async () => {  // 2. Resolve the promises to get the final ArrayBuffer array  const resolvedFontOptions = await resolveFonts([myCustomRegular, myCustomBold]);   return new ImageResponse(..., {   fonts: resolvedFontOptions  }); };    Always use resolveFonts before passing to fonts as image options.  await resolveFonts([myCustomRegular, myCustomBold]);  ðŸŒ Using Google Fonts  The GoogleFont class abstracts away all network logic, including fetching the CSS, parsing the .ttf file URL, and applying the internal cache.  Example  Define: Create instances of **GoogleFont, specifying the family name and desired weight. Resolve: Pass the instances to **resolveFonts.  import { ImageResponse, GoogleFont, resolveFonts } from '@ethercorps/sveltekit-og';  // 1. Define the GoogleFont instances const interRegular = new GoogleFont('Inter', {  weight: 400,  name: 'Inter',  // Optional: Only fetches characters needed for better performance  text: 'Hello World! 123' });  const interBold = new GoogleFont('Inter', {  weight: 700 });  export const GET = async () => {  // 2. Await the resolution (which triggers the fetch/cache lookup)  const resolvedFontOptions = await resolveFonts([interRegular, interBold]);   return new ImageResponse(..., {   fonts: resolvedFontOptions  }); };    Always use resolveFonts before passing to fonts as image options.  await resolveFonts([myCustomRegular, myCustomBold]);  â˜ï¸ Using Remote Fonts  If your font file is hosted on an external CDN or public URL, you can fetch it directly using the global fetch API. This is similar to Google Fonts but uses the CustomFont class, passing the fetch promise as the input.  Example  import { ImageResponse, CustomFont, resolveFonts } from '@ethercorps/sveltekit-og';  const REMOTE_FONT_URL = 'https://my-cdn.com/assets/FontAwesome-Regular.otf';  // 1. Define the CustomFont instance const fontAwesome = new CustomFont(  'Font Awesome',  // Pass a function that returns the ArrayBuffer promise from fetch  () => fetch(REMOTE_FONT_URL).then((res) => res.arrayBuffer()),  { weight: 400 } );  export const GET = async () => {  const resolvedFontOptions = await resolveFonts([fontAwesome]);   return new ImageResponse(..., {   fonts: resolvedFontOptions  }); };    Always use resolveFonts before passing to fonts as image options.  await resolveFonts([myCustomRegular, myCustomBold]);  ðŸ”¢ Multiple Font Sources  This example assumes you have two local files ($lib/assets/LocalFont-R.ttf, $lib/assets/LocalFont-B.ttf) and one custom remote font (https://cdn.example.com/icons.ttf).  import { ImageResponse, CustomFont, GoogleFont, resolveFonts } from '@ethercorps/sveltekit-og'; import { read } from '$app/server'; // Needed for local file reading  // --- Local Font Paths (Requires Vite + SvelteKit read) --- import LocalRegularPath from '$lib/assets/LocalFont-R.ttf?url'; import LocalBoldPath from '$lib/assets/LocalFont-B.ttf?url';  // --- Custom Remote URL --- const ICON_FONT_URL = 'https://cdn.example.com/icons.ttf';  export const GET = async () => {  // 1. Define all font instances  const fontsToLoad = [   // A. ðŸ“¦ LOCAL CUSTOM FONT (Uses $app/server/read via a function)   new CustomFont('Local App Font', () => read(LocalRegularPath).arrayBuffer(), { weight: 400 }),   new CustomFont('Local App Font', () => read(LocalBoldPath).arrayBuffer(), { weight: 700 }),    // B. ðŸŒ GOOGLE FONT (Uses internal fetch/cache)   new GoogleFont('Roboto Mono', {    weight: 500,    name: 'Roboto Mono',    text: 'Code: 123' // Optimize this fetch   }),    // C. â˜ï¸ CUSTOM REMOTE FONT (Uses global fetch)   new CustomFont('Custom Icons', () => fetch(ICON_FONT_URL).then((res) => res.arrayBuffer()), {    weight: 400   })  ];   // 2. Resolve all font buffers concurrently (local reads and network fetches)  const resolvedFontOptions = await resolveFonts(fontsToLoad);   // 3. Render the image  return new ImageResponse(   `                              Mixed Typography Title                                           const data = 'fetched data';                                           &#xe900;          `,   {    width: 1200,    height: 630,    fonts: resolvedFontOptions // Array of resolved ArrayBuffers   }  ); };    Always use resolveFonts before passing to fonts as image options.  await resolveFonts([myCustomRegular, myCustomBold]);"},{"title":"Using Local Assets","href":"/docs/utilities/local-assets","description":"Guide to hwo to handle assets in a SvelteKit server environment","content":"import { Callout } from \"@svecodocs/kit\";   When generating OG images, the code runs on the server (Node, Edge, or Worker), not in the browser. This means you cannot use relative paths (e.g., ``) because the image generation engine (Satori) has no access to your client-side assets or file system by default.  To use local images, you must provide them as either a Base64 Data URL or a Public Absolute URL.  Vite inline Import    Recommended for Self-Contained Images - $2    This method uses a Vite feature to embed the image data directly into your JavaScript, converting the asset into a Base64 string at build time. This results in a highly reliable, self-contained OG image.  ðŸ’¡ How it Works  The ?inline query suffix tells Vite to process the asset and export it as a string containing the Base64 data URL (data:image/png;base64,...). Since this string is available directly in your server-side code, it requires no file system access or network requests at runtime.  Example  Svelte Component    // 1. Import the asset using the ?inline suffix  import myLogoData from '$lib/assets/logo.png?inline';       My Base64 Title  Raw HTML/TS  import { ImageResponse } from '@ethercorps/sveltekit-og'; // Import the image directly as data URL import logoDataUrl from '$lib/assets/logo.png?inline';  export const GET = async () => {  const htmlToRender = `                    `;   return new ImageResponse(htmlToRender, { width: 1200, height: 630 }); };  Vite url Import  This method is used when you need the original file content (e.g., for fonts or large images) but want to read the file at runtime without making a network request.  ðŸ’¡ How it Works  The ?url suffix tells Vite to export the asset's path as a string (e.g., _app/immutable/assets/logo.png). The import {read} from \"$app/server\" function ($2) is a SvelteKit utility that can access built assets directly from the server's build directory and return an ArrayBuffer or Response. This is the safest way to read local assets in environments like Cloudflare or Vercel Edge.  Example  Reading into an ArrayBuffer  import { ImageResponse } from '@ethercorps/sveltekit-og'; // 1. Import the asset path string using ?url import imagePath from '$lib/assets/large_image.jpg?url'; import { read } from '$app/server'; // 2. Import the server read utility  export const GET = async ({ fetch }) => {  // 3. Read the content of the asset path using the utility  const assetResponse = await read(imagePath);  const imageBuffer = await assetResponse.arrayBuffer();   // 4. Convert ArrayBuffer to Base64 for Satori's consumption  const base64Image = Buffer.from(imageBuffer).toString('base64');  const mimeType = assetResponse.headers.get('content-type') || 'image/jpeg';  const dataUrl = data:${mimeType};base64,${base64Image};   const htmlToRender = `                    `;   return new ImageResponse(htmlToRender, { width: 1200, height: 630 }); };  Public Absolute Path  This method is the simplest for referencing assets placed in the static folder, but it requires knowing the final public URL of your application, making it less portable across environments.  ðŸ’¡ How it Works  Place the asset in your static folder (e.g., static/logo.png). The asset is served statically at the root (/logo.png). You must construct the full http(s):// URL using the request URL or environment variables to resolve the path. Satori requires the full absolute URL to fetch the image via HTTP.  Example  import { ImageResponse } from '@ethercorps/sveltekit-og'; import type { RequestHandler } from './$types';  export const GET: RequestHandler = async ({ url }) => {  // Construct the absolute URL using the request URL's origin  // Assumes logo.png is in the static folder  const absoluteUrl = ${url.origin}/logo.png;   const htmlToRender = `                    `;   return new ImageResponse(htmlToRender, { width: 1200, height: 630 }); };        In Edge Runtimes (Cloudflare, Vercel Edge, Deno), using fetch() to retrieve an asset from your own server (url.origin) can sometimes result in deployment loops or slow cold starts.  Method 1 (?inline) or Method 2 ($app/server/read) is strongly preferred in these environments."},{"title":"Raw HTML","href":"/docs/usage/html","description":"How to use raw HTML strings to generate images","content":"import { Callout } from \"@svecodocs/kit\";  Overview  Sometimes you might prefer using standard HTML files over Svelte componentsâ€”perhaps for performance, portability, or to decouple the design from the framework.  SvelteKit OG allows you to pass a raw HTML string directly to the ImageResponse constructor. By combining this with Vite's ?raw import suffix, you can load .html files and inject data using simple string replacement.  Guide  In this example, we will recreate the same GitHub card, but using a pure HTML file with placeholders (e.g., {repo}) and inline SVGs.  HTML Template  Create a file named og.html alongside your server file. Note that we are using standard class attributes for Tailwind. We also use placeholders like {owner} which we will replace programmatically.  src/routes/og/og.html                {owner}/     {repo}                  {description}                                                 {contributors}      Contributors                                              {open_issues}      Issues                                        {stars}      Stars                                                                {forks}      Forks API Route  In your server endpoint, import the HTML file using the ?raw suffix. This gives you the file content as a string. You can then perform standard string replacement to inject your dynamic data.    In this example, I have dropped the font and GitHub api request in favour of basic example. I have created specific section for $2.    src/routes/og/+server.ts  import { ImageResponse, type ImageResponseOptions } from '@ethercorps/sveltekit-og'; import type { RequestHandler } from './$types'; // 1. Import the HTML file as a raw string import ogHTML from './og.html?raw';  export const GET: RequestHandler = async ({ url }) => {  // 2. Get dynamic data (URL params or API fetch)  const owner = url.searchParams.get('owner') ?? 'etherCorps';  const repo = url.searchParams.get('repo') ?? 'sveltekit-og';   // 3. Define the data mapping  const replaceHolder = {   '{owner}': owner,   '{repo}': repo,   '{description}': 'Dynamic Open Graph Image Generator',   '{logo}': 'https://github.githubassets.com/assets/GitHub-Mark-ea2971cee799.png',   '{contributors}': 12,   '{forks}': 34,   '{open_issues}': 5,   '{stars}': 125  };   // 4. Perform String Replacement  let htmlToRender = ogHTML;  for (const [key, value] of Object.entries(replaceHolder)) {   // replaceAll handles multiple occurrences of the same placeholder   htmlToRender = htmlToRender.replaceAll(key, String(value) || '');  }   const imageOptions: ImageResponseOptions = {   width: 1200,   height: 630   // Optional: Add custom fonts here   // fonts: ...  };   // 5. Return the ImageResponse with the processed HTML string  return new ImageResponse(htmlToRender, imageOptions); };    The example above uses simple JavaScript string replacement. For more complex logic (conditionals, loops), you can process the string using a lightweight templating library like Handlebars or Mustache before passing it to ImageResponse.   Preview"},{"title":"Svelte Component","href":"/docs/usage/svelte","description":"How to use svelte component to generate image","content":"import { Callout, DemoContainer } from \"@svecodocs/kit\";     import SvelteComponentPlayground from \"$lib/components/playground/svelte-component.svelte\";  Prerequisites  Ensure you have configured the Vite/Rollup Plugin as described in the $2 section.    This guide uses $2 for icons and Svelte 5 Runes syntax.  Guide  In this guide, we will recreate the GitHub repository Open Graph image. We will create a reusable Svelte component and render it dynamically via an API endpoint.  GitHub OG Image:  Create your Component  Create a standard Svelte component. You can use props to make it dynamic.  src/lib/components/og.svelte    import Star from 'phosphor-svelte/lib/Star';  import Contributors from 'phosphor-svelte/lib/Users';  import Fork from 'phosphor-svelte/lib/GitFork';  import SealWarning from 'phosphor-svelte/lib/SealWarning';  import GithubLogo from 'phosphor-svelte/lib/GithubLogo';   type Props = {   logo: string;   owner: string;   repo: string;   description: string;   contributors: number;   open_issues: number;   stars: number;   forks: number;  };   const { open_issues, owner, forks, repo, stars, description, contributors, logo }: Props =   $props();   const details = [   {    title: 'Contributors',    count: contributors,    icon: Contributors   },   {    title: 'Stars',    count: stars,    icon: Star   },   {    title: 'Fork',    count: forks,    icon: Fork   },   {    title: 'Issues',    count: open_issues,    icon: SealWarning   }  ];                 {owner}/     {repo}                  {description}          {#each details as detail (detail.title)}                        {detail.count}       {detail.title}               {/each} Create API route  Create a server route to generate and serve the image. You can pass the Svelte component directly to ImageResponse. The third argument accepts the props object.  src/routes/og/+server.ts  import { ImageResponse } from '@ethercorps/sveltekit-og'; import { error, type RequestHandler } from '@sveltejs/kit'; import {  getRepoDetails,  type RepoDetailsError,  type RepoDetailsResponse,  cache,  type RepoContributorsResponse } from '../(github)/api'; import { tryCatch } from '$lib/try-catch'; import type { ImageResponseOptions } from '@ethercorps/sveltekit-og'; import OgComponent from './og.svelte'; import { fontsData } from '../(helpers)/fonts'; import type { ComponentProps } from 'svelte';  export const GET: RequestHandler = async ({ url }) => {  const details = {   owner: url.searchParams.get('owner') ?? 'etherCorps',   repo: url.searchParams.get('repo') ?? 'sveltekit-og'  };   const cacheKey = ${details.owner}/${details.repo};  let data = cache.get(cacheKey);   if (!data) {   const { data: response, error: githubError } = await tryCatch(getRepoDetails(details));   if (githubError) {    error(githubError?.response?.data?.status || 500, {     message: githubError?.response?.data?.message    });   }   if (response && response.repo.data) {    data = { ...response.repo.data, contributors_count: response.contributors.data.length };    cache.set(${details.owner}/${details.repo}, data);   }  }   const props: ComponentProps = {   owner: data?.owner.login as string,   repo: data?.name as string,   description: String(data?.description),   contributors: data?.contributors_count as number,   forks: data?.forks as number,   open_issues: data?.open_issues as number,   stars: data?.stargazers_count as number,   logo: data?.owner.avatar_url as string  };   const imageOptions: ImageResponseOptions = {   width: 1200,   height: 630,   debug: false,   fonts: await fontsData(),   headers: {    'Cache-Control': 'no-cache, no-store'   }  };   return new ImageResponse(OgComponent, imageOptions, props); };  Preview  Start development server and visit the URL. You can change the query parameters to see the image update instantly in $2.  Using Vanilla CSS  The examples above use Tailwind CSS (via the tw prop or class names automatically handled by the library). However, you can also use standard CSS within your Svelte `` blocks.     If using style blocks, you must enable CSS injection in your component options.          // component logic     Hello World     .card {   display: flex;   background-color: white;   height: 100%;   align-items: center;   justify-content: center;  }  h1 {   font-size: 60px;   color: black;  }  Using Local Assets  When generating OG images, you cannot use relative paths (e.g., src=\"./logo.png\") because the image generation happens on the server, not in a browser. The Satori engine cannot \"see\" your file system or resolve relative client-side paths.  To use local images, you must convert them into Base64 Data URLs. Fortunately, Vite makes this easy.  The ?inline Suffix  You can import any image file with the ?inline suffix. This tells Vite to ignore its usual asset handling and instead provide the file's content as a Base64 string at build time.  usage in Svelte Components    // 1. Import with ?inline  import myLogo from '$lib/assets/logo.png?inline';       My Website  Using Public Folder Images  Technically, you can use images from your static folder, but you must provide the full absolute URL (e.g., https://your-site.com/logo.png).  Dev: http://localhost:5173/logo.png  Prod: https://example.com/logo.png  Since you likely don't know the absolute domain at build time (or in preview environments), we strongly recommend using the ?inline method described above.  Playground"},{"title":"Sveltekit Prerender","href":"/docs/usage/sveltekit-prerender","description":"Using `prerender` with Sveltekit OG to generate static Open Graph images at build time.","content":""}]