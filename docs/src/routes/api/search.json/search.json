[
	{
		"title": "Getting Started",
		"href": "/docs/getting-started",
		"description": "A quick guide to get started using Sveltekit OG",
		"content": "import { Callout } from \"@svecodocs/kit\";  import { Steps, Step } from \"@svecodocs/kit\";     import NodePackageInstallerTabs from \"$lib/components/add-ons/installer-tabs.svelte\";     import InstallSveltekitOg from \"$lib/components/add-ons/packages/sveltekit-og.md\";  Setup: Installation & Plugin  Setting up SvelteKit OG is a two-step process: installing the core package and adding the necessary plugin to handle wasm file for build.    We strongly suggest using sveltekit-og v4 as older versions are not maintained. Sveltekit OG v4 only supports Svelte v5 (Runes) and later. We are not planning to support Svelte v4.      Installation  Install the package using your preferred package manager:    Plugins Configuration  Sveltekit OG requires a plugin to handle native dependencies (WASM). You must use one of the two options below.  Vite Plugin  This is the preferred method for SvelteKit v4.1.0 onwards. It uses the simpler sveltekitOG function.    The Vite plugin is available from sveltekit-og@v4.1.0. If you are using v4.0.0, you must use the $2 configuration below. If you add the plugin while the dev server is running, please stop and restart the server to ensure the plugin is applied correctly.    import { sveltekit } from '@sveltejs/kit/vite'; import { sveltekitOG } from '@ethercorps/sveltekit-og/plugin'; const config = {  plugins: [sveltekit(), sveltekitOG()] };  export default config;  Rollup Plugin  This plugin is primarily exist because of my own mistake.   The Rollup plugin will be deprecated in v5 of SvelteKit OG. Please migrate to the Vite plugin if possible.    import { sveltekit } from '@sveltejs/kit/vite'; import { rollupWasm } from '@ethercorps/sveltekit-og/plugin'; const config = {  plugins: [sveltekit()],  build: {   rollupOptions: {    plugins: [rollupWasm()]   }  } };  export default config;  Next Steps  Once the package is installed and the plugin is configured, you are ready to create your first dynamic image by defining a SvelteKit server route and returning an ImageResponse. For Svelte Components**: If you prefer building your images using .svelte files, see the $2 guide. For Raw HTML**: If you prefer using pure HTML strings with Tailwind CSS, see the $2 guide."
	},
	{
		"title": "Introduction",
		"href": "/docs/index",
		"description": "What exactly is Sveltekit OG?",
		"content": "import { Callout } from '@svecodocs/kit'   SvelteKit OG is a high-performance utility library designed for server-side image generation within SvelteKit applications.  While its primary use is creating dynamic Open Graph (OG) images for rich social media preview cards, the library is a generic tool capable of converting Svelte components or HTML/CSS into high-quality PNGs, suitable for a wide range of use cases .  It allows you to define a single visual template using modern web technologies and render unique, personalized images on the fly based on dynamic data or URL parameters.  Zero-Browser Rendering  SvelteKit OG achieves its speed and efficiency by relying on two core technologies, entirely avoiding the performance cost of launching a headless browser like Puppeteer:  Satori (Vercel): This engine takes your standard HTML and CSS (Flexbox, Tailwind) and converts it into an SVG representation. Resvg: This powerful Rust-based library then takes the generated SVG and converts it into the final PNG or JPEG image file that is served to the client.  This combination ensures the library runs efficiently in serverless and edge environments (like Vercel Edge, Cloudflare Workers, or Netlify functions).  Key Features & Benefits  ðŸš€ Fast & Lightweight: Unlike Puppeteer or Playwright, sveltekit-og does not launch a browser instance. It runs efficiently in serverless and edge environments (like Vercel Edge or Cloudflare Workers).  ðŸŽ¨ Easy Styling: Style your images using standard CSS (Flexbox) or built-in Tailwind CSS support. If you know how to center a div, you know how to design an OG image.  ðŸ§© Svelte Component Support: You aren't limited to raw HTML strings. You can import and render actual .svelte components inside your image templates.  Typography:   Support for custom fonts and Google Fonts.   Support for Emojis.  ðŸ› ï¸ Developer Experience:   TypeScript Ready: Fully typed for a better development experience.   Debug Mode: Inspect the generated layout bounding boxes to fine-tune your designs."
	},
	{
		"title": "Release",
		"href": "/docs/release",
		"description": "sveltekit-og package release history and latest version.",
		"content": "import ReleasePage from \"$lib/components/add-ons/release.svelte\""
	},
	{
		"title": "Assets Loading",
		"href": "/docs/advanced-usage/local-assets",
		"description": "Guide to handling local images, SVGs, and remote assets in a SvelteKit server environment.",
		"content": "import { Callout, Tabs, TabItem } from \"@svecodocs/kit\";      const exampleTabs = [\"Svelte Component\", \"Raw HTML\"]   When generating OG images, the code runs on the server (Node, Edge, or Worker), not in the browser. This means you cannot use relative paths (e.g., ``) because the image generation engine (Satori) has no access to your client-side assets or file system by default.  To use local assets, you must provide the image data as either a Base64 Data URL or instruct Satori to fetch it via a Public Absolute URL.  Vite Inline Import  This is the recommended method for small, self-contained images (logos, avatars) because it requires no runtime file system access or network requests.  How it Works  The ?inline query suffix is a Vite feature that processes the asset at build time and exports it as a string containing the Base64 Data URL (data:image/png;base64,...). Since this string is available directly in your server-side code, the image generation is highly reliable and fast.  Example           // 1. Import the asset using the ?inline suffix (exports a base64 data URL string)     import myLogoData from '$lib/assets/logo.png?inline';             My Base64 Title           import { ImageResponse } from '@ethercorps/sveltekit-og'; // Import the image directly as a Base64 data URL string import logoDataUrl from '$lib/assets/logo.png?inline';  export const GET = async () => {  const htmlToRender = `                    `;   return new ImageResponse(htmlToRender, { width: 1200, height: 630 }); };  Reading Local Assets  This method is ideal for large assets (e.g., high-resolution background images) or files you need as an ArrayBuffer (like custom fonts), where embedding the file with ?inline is too large.  How it Works  The ?url suffix tells Vite to export the asset's path as a string (e.g., $lib/assets/logo.png). The SvelteKit utility  $app/server/read uses this path to access the asset within the server's build directory and returns the content as a Response. Example  Reading into an ArrayBuffer  import { ImageResponse } from '@ethercorps/sveltekit-og'; // 1. Import the asset path string using ?url import imagePath from '$lib/assets/large_image.jpg?url'; import { read } from '$app/server'; // 2. Import the server read utility  export const GET = async ({ fetch }) => {  // 3. Read the content of the asset path using the utility  const assetResponse = await read(imagePath);  const imageBuffer = await assetResponse.arrayBuffer();   // 4. Convert ArrayBuffer to Base64 for Satori's consumption  const base64Image = Buffer.from(imageBuffer).toString('base64');  const mimeType = assetResponse.headers.get('content-type') || 'image/jpeg';  const dataUrl = data:${mimeType};base64,${base64Image};   const htmlToRender = `                    `;   return new ImageResponse(htmlToRender, { width: 1200, height: 630 }); };  Using Public Absolute Path  This method is the simplest for referencing assets placed in the static folder, but it relies on making an HTTP network request during image generation.  How it Works  Satori's rendering engine requires a full absolute URL (e.g., https://example.com/logo.png) to fetch the image via HTTP. You must construct this URL using the request URL's origin.  Example  import { ImageResponse } from '@ethercorps/sveltekit-og'; import type { RequestHandler } from './$types';  export const GET: RequestHandler = async ({ url }) => {  // Construct the absolute URL using the request URL's origin  // Assumes logo.png is in the static folder  const absoluteUrl = ${url.origin}/logo.png;   const htmlToRender = `                    `;   return new ImageResponse(htmlToRender, { width: 1200, height: 630 }); };  [//]: # () [//]: # ( )  [//]: # (    ) [//]: # (In Edge Runtimes &#40;Cloudflare, Vercel Edge, Deno&#41;, using fetch&#40;&#41; to retrieve an asset from your own server &#40;url.origin&#41; can sometimes slow cold starts.  )  [//]: # (- Method 1 &#40;?inline&#41; or Method 2 &#40;$app/server/read&#41; is strongly preferred in these environments.)  [//]: # ()"
	},
	{
		"title": "Pre-rendering OG Images",
		"href": "/docs/advanced-usage/pre-rendering",
		"description": "How to use SvelteKit's pre-rendering Open Graph images for static routes.",
		"content": "import { Callout } from \"@svecodocs/kit\";   Pre-rendering generates your OG images at build time, not at runtime. This eliminates the serverless function execution cost and latency when a bot first crawls the image, resulting in superior performance and reduced infrastructure costs.  You achieve this using SvelteKit's built-in prerender feature on the server route.    To make a route pre-rendered, you need to export the prerender constant and set it to true in your server route file (e.g., +server.ts).  export const prerender = true;  Why Pre-render? Pre-rendering OG images at build time offers several advantages: Performance**: Images are generated once during the build, resulting in instant delivery to users without server-side rendering delays. Reliability**: Eliminates runtime dependencies and potential failures in image generation. Scalability**: Reduces server load since images are served as static assets.  Single Static Route  For routes like /about or /landing, you can force the OG image route to be pre-rendered into a static file (e.g., build/og/image.png).  Example  Let's assume your page is at /about and its OG image endpoint is /about/og.png.  import { ImageResponse } from '@ethercorps/sveltekit-og'; import AboutCard from '$lib/og/AboutCard.svelte'; import type { RequestHandler } from './$types';  // 1. Enable prerendering for this route export const prerender = true;  export const GET: RequestHandler = async () => {  // Data is static for the About page  const props = {   title: \"About Our Project\",   stats: 100  };   // 2. ImageResponse generates the static PNG during the build process  return new ImageResponse(AboutCard, {   width: 1200,   height: 630,   // Set aggressive caching since the image will never change   headers: {    'Cache-Control': 'public, immutable, max-age=31536000'   }  }, props); };  Dynamic Paths  This is the standard and most powerful use case. For a documentation site, you need to pre-render an OG image for every documentation page (/docs/a, /docs/b, etc.) based on dynamic data you can access during the build.  This requires a dynamic SvelteKit route that implements the entries function.  Case Study: Sveltekit OG Docs  In the sveltekit-og documentation, the OG images for all documentation pages are pre-rendered using an endpoint at /api/og/image/[...slug].png.  Defining Dynamic Entries  The entries function is critical. It tells SvelteKit which dynamic paths to build. In a documentation site, this means loading your index data and returning an entry for every document.    It is highly recommended to append a file extension like .png or .svg to your dynamic server route, for example: [...slug].png.  Why this helps: Clarity**: It immediately signals that the endpoint returns an image file, not JSON or HTML. Caching: CDNs and browsers often use the file extension to automatically set the correct **Content-Type and apply highly aggressive file caching strategies, which is essential for performance.    // We use a glob import to get metadata for all markdown files in the documentation directory import { docFiles } from '$lib/docs/data'; import type { EntryGenerator, RequestHandler } from './$types';  // The function that tells SvelteKit which URLs to pre-render export const entries: EntryGenerator = () => {     // 1. Get all documentation file paths     const slugs = docFiles.map((doc) => doc.slug);      // 2. Return the required format for SvelteKit: {slug: [...parts]}     return slugs.map((slug) => ({         // Converts a slug like '/usage/basic-generation' into the array ['usage', 'basic-generation']         slug: slug.slice(1).split('/')     })); };  // ... (Rest of the file continues with the GET function)  API Handler  The GET request handler function then handles two scenarios: During Build: SvelteKit calls GET for every entry defined by entries. It retrieves the data for that specific document (params.slug) and generates the PNG. At Runtime: If a new, unlisted path is hit, it will dynamically generate the image (though this is rare for documentation).  import { getDocData } from '$lib/docs/data'; // Utility to fetch doc data by slug import DocCard from '$lib/og/DocCard.svelte'; // The Svelte Component template import { resolveFonts } from '$lib/fonts/utils';  import { ImageResponse } from '@ethercorps/sveltekit-og'; import type { RequestHandler } from './$types';  // 1. Pre-render is enabled export const prerender = true;  // ... (entries function from above is here) ...  export const GET: RequestHandler = async ({ params }) => {     const slug = '/' + params.slug.join('/');     const docData = getDocData(slug); // Get the title, description, etc. for the markdown file      if (!docData) {         // Handle case where the slug doesn't exist         return new Response(null, { status: 404 });     }      const resolvedFonts = await resolveFonts(); // Pre-loaded font data      const props = {         title: docData.title,         description: docData.description,         // ... other props like section, icon, etc.     };      return new ImageResponse(         DocCard,         {             width: 1200,             height: 630,             fonts: resolvedFonts,             // Caching for long-term storage since it's pre-rendered             headers: {                 'Cache-Control': 'public, immutable, max-age=31536000'             }         },         props     ); }; By setting prerender = true and implementing entries, every single documentation image is ready before the site is deployed, leading to maximum performance.  Safety Considerations  When pre-rendering OG images, ensure that: All necessary data is available at build time. You handle missing data gracefully to avoid build failures.  To achieve above mentioned safety considerations, you can add handleUnseenRoutes, handleHttpError, and handleMissingId to prerender section in svelte.config.js. which will help you to manage unseen routes, HTTP errors, and missing IDs during the pre-rendering process.  import adapter from '@sveltejs/adapter-vercel';  /** @type {import('@sveltejs/kit').Config} */ const config = {  // Consult https://kit.svelte.dev/docs/integrations#preprocessors  // for more information about preprocessors  preprocess: adapter({   split: true,  }),   kit: {   // adapter-auto only supports some environments, see https://kit.svelte.dev/docs/adapter-auto for a list.   // If your environment is not supported or you settled on a specific environment, switch out the adapter.   // See https://kit.svelte.dev/docs/adapters for more information about adapters.   adapter: adapter(),   prerender: {    handleUnseenRoutes: (details) => {     console.warn('handleUnseenRoutes', JSON.stringify(details, null, 2));     return;    },    handleHttpError: ({ path, message }) => {     console.log('handleHttpError', path, message);     // ignore deliberate link to shiny 404 page     if (path.split('/').length === 2) return;      if (path.startsWith('/og.png')) return;      // otherwise fail the build     throw new Error(message);    },    handleMissingId: (details) => {     console.log('handleMissingId', JSON.stringify(details, null, 2));     return;    }   }  } };  export default config; `"
	},
	{
		"title": "Cloudflare",
		"href": "/docs/runtime/cloudflare",
		"description": "How to use Sveltekit OG with cloudflare adapter (@sveltejs/cloudflare-adapter)",
		"content": "import { Callout} from '@svecodocs/kit';     import NodePackageInstallerTabs from \"$lib/components/add-ons/installer-tabs.svelte\";      import InstallCloudflareAdapter from \"$lib/components/add-ons/packages/sveltekit-adapter/cloudflare.md\";    This section details the necessary configuration to ensure the SvelteKit OG's image generation engine, which relies on WebAssembly (Wasm), is correctly bundled and executed within the Cloudflare Workers or Pages runtime environment.  Installation  To deploy with Cloudflare, you must first install the necessary SvelteKit adapter:    In your svelte.config.js, configure the adapter:  import adapter from '@sveltejs/adapter-cloudflare';  const config = {   ...,     kit: {         adapter: adapter()     },     ... }; export default config;  Plugin Configuration  The image generation uses the @resvg/resvg-wasm, satori, yoga, which relies on a Wasm module. The official SvelteKit OG plugins handle the complex Wasm bundling required for the build/runtime. You must choose one of the following plugins based on your sveltekit-og version.  Vite Plugin (Recommended)    Vite plugin is available from sveltekit-og@v4.1.0. If you are using v4.0.0 use $2 plugin.  If you add the plugin while the dev server is running, you might see no generated image. Stop the server and re-start it.    Add the sveltekitOG plugin to your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { sveltekitOG } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [   sveltekit(),   sveltekitOG() // Add the Vite plugin  ] });  export default config;  Rollup Plugin (Legacy)   The Rollup plugin will be deprecated in v5. Migrate to the Vite plugin when possible.   Add the rollupWasm plugin inside the rollupOptions block in your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { rollupWasm } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [sveltekit()],  build: {   rollupOptions: {    // Add rollupWasm plugin for Cloudflare compatibility    plugins: [rollupWasm()]   }  } });  export default config;  Usage  Once configured, the usage remains the same as any other SvelteKit environment.  Svelte Components: Refer to the $2 usage.  Raw HTML: Refer to the $2 for usage with string templates.  Preview  Cloudflare Workers    Source: https://github.com/etherCorps/sveltekit-og/tree/main/examples/cf-workers-build  Live: https://workers.sveltekit-og.dev/cog  Cloudflare Pages    Source: https://github.com/etherCorps/sveltekit-og/tree/main/examples/cf-pages-build  Live: https://pages.sveltekit-og.dev/cog"
	},
	{
		"title": "Deno Deploy",
		"href": "/docs/runtime/deno",
		"description": "How to use Sveltekit OG with the Deno adapter (svelte-adapter-deno)",
		"content": "import { Callout, Collapsible } from '@svecodocs/kit';     import NodePackageInstallerTabs from \"$lib/components/add-ons/installer-tabs.svelte\";      import InstallDenoAdapter from \"$lib/components/add-ons/packages/sveltekit-adapter/deno.md\";    This section details the configuration needed to deploy SvelteKit OG using the Deno adapter (svelte-adapter-deno), targeting the Deno Runtime (Deno Deploy).  Installation  To deploy with deno, you must first install the necessary SvelteKit adapter:    In your svelte.config.js, configure the adapter:  import adapter from 'svelte-adapter-deno';  const config = {   ...,     kit: {         adapter: adapter()     },     ... }; export default config;  Plugin Configuration  The image generation uses the @resvg/resvg-wasm, satori, yoga, which relies on a Wasm module. The official SvelteKit OG plugins handle the complex Wasm bundling required for the build/runtime. You must choose one of the following plugins based on your sveltekit-og version.  Vite Plugin (Recommended)    Vite plugin is available from sveltekit-og@v4.1.0. If you are using v4.0.0 use $2 plugin.  If you add the plugin while the dev server is running, you might see no generated image. Stop the server and re-start it.    Add the sveltekitOG plugin to your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { sveltekitOG } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [   sveltekit(),   sveltekitOG() // Add the Vite plugin  ] });  export default config;  Rollup Plugin (Legacy)   The Rollup plugin will be deprecated in v5. Migrate to the Vite plugin when possible.   Add the rollupWasm plugin inside the rollupOptions block in your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { rollupWasm } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [sveltekit()],  build: {   rollupOptions: {    // Add rollupWasm plugin for Cloudflare compatibility    plugins: [rollupWasm()]   }  } });  export default config;  Usage  Once configured, the usage remains the same as any other SvelteKit environment.  Svelte Components: Refer to the $2 usage.  Raw HTML: Refer to the $2 for usage with string templates.  Preview    Source: https://github.com/etherCorps/sveltekit-og/tree/main/examples/deno-build  Live: https://deno.sveltekit-og.dev/cog  Known Issues    Deno throws error when we use $2  import imagePath from '$lib/assets/JetBrainsMono-Regular.ttf?url';  or  import imagePath from '$lib/assets/JetBrainsMono-Regular.ttf';  Error:  NotFound: No such file or directory (os error 2): open '_app/immutable/assets/JetBrainsMono-Regular.Dh36KTnx.ttf'     at Object.openSync (ext:deno_fs/30_fs.js:543:15)     at read (file:///app/src/.deno-deploy/handler.ts:55:25)     at wrapped_read (file:///app/src/.deno-deploy/server/index.js:4390:24)     at read (file:///app/src/.deno-deploy/server/entries/endpoints/_server.ts.js:142:25)     at CustomFont.weight [as input] (file:///app/src/.deno-deploy/server/entries/endpoints/_server.ts.js:154:42)     at fallback (file:///app/src/.deno-deploy/server/entries/endpoints/_server.ts.js:40:74)     at eventLoopTick (ext:core/01_core.js:179:7)     at async file:///app/src/.deno-deploy/server/entries/endpoints/_server.ts.js:97:24     at async Promise.all (index 0)     at async resolveFonts (file:///app/src/.deno-deploy/server/entries/endpoints/_server.ts.js:96:25)"
	},
	{
		"title": "Netlify",
		"href": "/docs/runtime/netlify",
		"description": "How to use Sveltekit OG with netlify adapter (@sveltejs/adapter-netlify)",
		"content": "import { Callout, Collapsible } from '@svecodocs/kit';     import NodePackageInstallerTabs from \"$lib/components/add-ons/installer-tabs.svelte\";      import InstallNetlifyAdapter from \"$lib/components/add-ons/packages/sveltekit-adapter/netlify.md\";    This section details the configuration needed to use SvelteKit OG with the Netlify Adapter (@sveltejs/adapter-netlify), targeting the Netlify Functions environment (which uses Node.js).  Netlify Functions, similar to Vercel Serverless Functions, are a Node.js-based environment that generally supports the Wasm module dependencies required by the image generation engine. However, the SvelteKit OG plugins ensure the Wasm files are correctly bundled and available within the function context.  Installation  First, ensure you have the Netlify adapter installed:   In your svelte.config.js, configure the adapter:  import adapter from 'svelte-adapter-deno';  const config = {   ...,     kit: {         adapter: adapter()     },     ... }; export default config;  Plugin Configuration  The image generation uses the @resvg/resvg-wasm, satori, yoga, which relies on a Wasm module. The official SvelteKit OG plugins handle the complex Wasm bundling required for the build/runtime. You must choose one of the following plugins based on your sveltekit-og version.  Vite Plugin (Recommended)    Vite plugin is available from sveltekit-og@v4.1.0. If you are using v4.0.0 use $2 plugin.  If you add the plugin while the dev server is running, you might see no generated image. Stop the server and re-start it.    Add the sveltekitOG plugin to your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { sveltekitOG } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [   sveltekit(),   sveltekitOG() // Add the Vite plugin  ] });  export default config;  Rollup Plugin (Legacy)   The Rollup plugin will be deprecated in v5. Migrate to the Vite plugin when possible.   Add the rollupWasm plugin inside the rollupOptions block in your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { rollupWasm } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [sveltekit()],  build: {   rollupOptions: {    // Add rollupWasm plugin for Cloudflare compatibility    plugins: [rollupWasm()]   }  } });  export default config;  Usage  Once configured, the usage remains the same as any other SvelteKit environment.  Svelte Components: Refer to the $2 usage.  Raw HTML: Refer to the $2 for usage with string templates.  Preview    Source: https://github.com/etherCorps/sveltekit-og/tree/main/examples/netlify-build  Live: https://netlify.sveltekit-og.dev/cog  Known Issues    Netlify throws error when we use $2  import imagePath from '$lib/assets/large_image.jpg?url';"
	},
	{
		"title": "Node JS",
		"href": "/docs/runtime/node",
		"description": "How to use Sveltekit OG with the node adapter (@sveltejs/adapter-node)",
		"content": "import { Callout} from '@svecodocs/kit';     import NodePackageInstallerTabs from \"$lib/components/add-ons/installer-tabs.svelte\";      import InstallNodeAdapter from \"$lib/components/add-ons/packages/sveltekit-adapter/node.md\";    This section details the necessary configuration to use SvelteKit OG with the Node Adapter (@sveltejs/adapter-node), targeting a standard self-hosted Node.js server environment.  Installation  First, ensure you have the Node adapter installed:   In your svelte.config.js, configure the adapter:  import adapter from '@sveltejs/adapter-node';  const config = {   ...,     kit: {         adapter: adapter()     },     ... }; export default config;  Plugin Configuration  You must use one of the SvelteKit OG plugins and explicitly set the esmImport option to false. This configuration ensures the Wasm module is loaded using Node's standard functions, providing reliable execution in the Node environment.  Vite Plugin (Recommended)    Vite plugin is available from sveltekit-og@v4.1.0. If you are using v4.0.0 use $2 plugin.  If you add the plugin while the dev server is running, you might see no generated image. Stop the server and re-start it.    Add the sveltekitOG plugin to your vite.config.ts, passing { esmImport: false } to the options.  import { sveltekit } from '@sveltejs/kit/vite'; import { sveltekitOG } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [   sveltekit(),   sveltekitOG({    esmImport: false // Crucial for reliable Wasm loading in Node.js   })  ] });  export default config;  Rollup Plugin (Legacy)    The Rollup plugin will be deprecated in v5. Migrate to the Vite plugin when possible.    If using the Rollup plugin, apply { esmImport: false } directly to the rollupWasm plugin configuration within rollupOptions.  import { sveltekit } from '@sveltejs/kit/vite'; import { rollupWasm } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [sveltekit()],  build: {   rollupOptions: {    plugins: [     rollupWasm({      esmImport: false // Crucial for reliable Wasm loading in Node.js     })    ]   }  } });  export default config;  Usage  Once configured, the usage remains the same as any other SvelteKit environment.  Svelte Components: Refer to the $2 usage.  Raw HTML: Refer to the $2 for usage with string templates.  Preview (Self Test)  Source: https://github.com/etherCorps/sveltekit-og/tree/main/examples/node-build  To verify the Node setup works correctly, you can clone and run the dedicated example repository.  Step-by-Step Guide  Clone the Repository and Navigate:  git clone https://github.com/etherCorps/sveltekit-og.git cd sveltekit-og/examples/node-build  Install Dependencies:  pnpm install  Build the Project**: This command runs the build process, applying the @sveltejs/adapter-node and the Wasm plugins, resulting in a deployable Node server build in the ./build directory.  pnpm run build  Start the preview Server**: This command starts the Node server using the generated output.  pnpm run preview  More on how to use $2"
	},
	{
		"title": "Vercel",
		"href": "/docs/runtime/vercel",
		"description": "How to use Sveltekit OG with the vercel adapter (@sveltejs/adapter-vercel)",
		"content": "import { Callout} from '@svecodocs/kit';     import NodePackageInstallerTabs from \"$lib/components/add-ons/installer-tabs.svelte\";      import InstallVercelAdapter from \"$lib/components/add-ons/packages/sveltekit-adapter/vercel.md\";    This section details the configuration needed to use SvelteKit OG with the Vercel Adapter (@sveltejs/adapter-vercel), targeting the Vercel Edge Runtime or Serverless Functions (Node).  Installation  First, ensure you have the Vercel adapter installed:    In your svelte.config.js, configure the adapter:  import adapter from '@sveltejs/adapter-vercel';  const config = {   ...,     kit: {         adapter: adapter()     },     ... }; export default config;  Plugin Configuration  The image generation uses the @resvg/resvg-wasm, satori, yoga, which relies on a Wasm module. The official SvelteKit OG plugins handle the complex Wasm bundling required for the runtime. You must choose one of the following plugins based on your sveltekit-og version.  Vite Plugin (Recommended)    Vite plugin is available from sveltekit-og@v4.1.0. If you are using v4.0.0 use $2 plugin.  If you add the plugin while the dev server is running, you might see no generated image. Stop the server and re-start it.    Add the sveltekitOG plugin to your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { sveltekitOG } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [   sveltekit(),   sveltekitOG() // Add the Vite plugin  ] });  export default config;  Rollup Plugin (Legacy)   The Rollup plugin will be deprecated in v5. Migrate to the Vite plugin when possible.   Add the rollupWasm plugin inside the rollupOptions block in your vite.config.ts.  import { sveltekit } from '@sveltejs/kit/vite'; import { rollupWasm } from '@ethercorps/sveltekit-og/plugin'; import { defineConfig } from 'vite';  const config = defineConfig({  plugins: [sveltekit()],  build: {   rollupOptions: {    // Add rollupWasm plugin for Cloudflare compatibility    plugins: [rollupWasm()]   }  } });  export default config;  Edge and Serverless Split  The SvelteKit Vercel adapter supports specifying the runtime on a per-route basis. This is highly recommended to isolate your computationally intensive OG image route into the smaller, faster Edge or Fluid Runtime, while keeping other APIs on the larger, more flexible Serverless (Node) runtime.  You can achieve this by adding a +server.ts configuration file alongside your OG image route.  Edge  This route runs on the Edge Runtime:  // 1. Specify the runtime for this route export const config = {  runtime: 'edge', // Use the Vercel Edge Runtime  split: true // Recommended to ensure isolation };  import { ImageResponse } from '@ethercorps/sveltekit-og'; import type { RequestHandler } from './$types';  export const GET: RequestHandler = async () => {  // Your standard ImageResponse logic here  return new ImageResponse(/* ... */); };    When targeting the Edge Runtime (via export const config = { runtime: 'edge' }), your entire function size, including all dependencies (like the Satori Wasm module and fonts), must be under the 1MB limit. Using many custom fonts or large components can easily exceed this size, resulting in deployment failure.  Serverless (Node) Runtime  // No 'config' export means it defaults to the Node Serverless Function. You can use split config here too. import type { RequestHandler } from './$types'; import { ImageResponse } from '@ethercorps/sveltekit-og';  export const GET: RequestHandler = async () => {  return new ImageResponse(/* ... */); };  Usage  Once configured, the usage remains the same as any other SvelteKit environment.  Svelte Components: Refer to the $2 usage.  Raw HTML: Refer to the $2 for usage with string templates.  Preview    Source: https://github.com/etherCorps/sveltekit-og/tree/main/examples/vercel-build  Live: https://vercel.sveltekit-og.dev/sc"
	},
	{
		"title": "Raw HTML",
		"href": "/docs/usage/html",
		"description": "How to use raw HTML strings to generate images",
		"content": "import { Callout } from \"@svecodocs/kit\";  Overview  Sometimes you might prefer using standard HTML files over Svelte componentsâ€”perhaps for performance, portability, or to decouple the design from the framework.  Prerequisites  Ensure, Vite/Rollup Plugin configuration as described in the $2.  Guide  This guide shows the most basic functionality: rendering a static image directly from an HTML string, without Svelte components.  HTML Template  Define the HTML string directly in +server.ts file. Remember to use inline styles or utility classes, as the image renderer does not process external CSS files.  const htmlString = `   @ethercorps/sveltekit-og  Your Raw HTML Open Graph Image!  `;  API Route  The key difference here is that you pass the string as the first argument to ImageResponse. The third argument (for Svelte component props) is not used.  // Auto added by remark-code-import  Preview  Visit the URL corresponding to route in browser (e.g. http://localhost:5173/images/raw-html.png).  Next Steps  Dynamic Data: To inject dynamic data (e.g., a post title) into your HTML string, you will need to use JavaScript string replacement or a dedicated **templating engine before passing the string to ImageResponse. Types Reference**: For a full overview of all options and parameters for ImageResponse, see $2 reference guide. Local Assets**: To include local images or other assets in OG images, see $2 guide. Custom Fonts**: To use fonts other than the default, see $2 guide for detailed instructions."
	},
	{
		"title": "Svelte Component",
		"href": "/docs/usage/svelte",
		"description": "The simplest guide to generating your first static OG image using svelte component.",
		"content": "import { Callout, DemoContainer } from '@svecodocs/kit';     import SvelteComponentPlayground from '$lib/components/playground/svelte-component.svelte';  Prerequisites  Ensure, Vite/Rollup Plugin configuration as described in the $2.  Guide  We will create the simplest possible Open Graph image. This example uses a Svelte component without any dynamic data fetching or complex logic.  Create your Component  Component should use standard HTML and CSS (or utility classes from Tailwind CSS). Ensure the component's root element has a style of width: 100% and height: 100% to correctly fill the rendering area defined in the options.    If using style blocks, you must enable CSS injection in svelte options.      // Auto added from source file  Create API route  Create a SvelteKit server route (a +server.ts file) and use the ImageResponse constructor to render your component. For this basic setup, we include only the mandatory configuration: the component, dimensions, and necessary fonts.   // Auto added from source file  Preview  Visit the URL corresponding to route in browser (e.g. http://localhost:5173/images/simple.png).  Using Vanilla CSS  The examples above use Style attribute. However, you can also use standard CSS within Svelte Component `` block or use Tailwind CSS.    If using style blocks, you must enable CSS injection in svelte options.         // component props     Hello World     .card {   display: flex;   background-color: white;   height: 100%;   align-items: center;   justify-content: center;  }  h1 {   font-size: 60px;   color: black;  }  Next Steps  Types Reference**: For a full overview of all options and parameters for ImageResponse, see $2 reference guide. Local Assets**: To include local images or other assets in OG images, see $2 guide. Custom Fonts**: To use fonts other than the default, see $2 guide for detailed instructions."
	},
	{
		"title": "Auto-Gen OG Image Route",
		"href": "/docs/examples/auto-generate-routes",
		"description": "How to automatically generate OG image routes in SvelteKit using Vite plugin.",
		"content": "import { Callout } from \"@svecodocs/kit\";   This guide demonstrates how to create a custom Vite plugin that automatically generates the required SvelteKit server routes (og.png/+server.ts) for Open Graph images, based on a simple configuration file (sveltekit.og.ts) you place in your routes.  Here is the complete guide, rewritten as an in-depth, executable Example demonstrating how to create and use the custom Vite route generator.  Prerequisites  First, we need a single, reusable file that contains the shared logic for image generation, font loading, and error handling. This file is imported by every auto-generated server route.  Create a file at src/lib/og-image.ts with the following content:  import { ImageResponse } from \"@ethercorps/sveltekit-og\"; import ShadcnOG from \"./components/shadcn-og.svelte\"; import { GoogleFont, resolveFonts } from \"@ethercorps/sveltekit-og/fonts\"; import type { ComponentProps } from \"svelte\"; import type { RequestHandler } from \"@sveltejs/kit\";  type OgImageMetadata = ComponentProps;  const fonts = [  new GoogleFont(\"Geist\", { weight: 400 }),  new GoogleFont(\"Geist\", { weight: 600 }),  new GoogleFont(\"Geist Mono\", { weight: 400 }), ];  export const generateOgImage = async (metadata: OgImageMetadata) => {  console.log(\"Generating OG image with metadata:\", metadata);  return new ImageResponse(   ShadcnOG,   {    height: 630,    width: 1200,    fonts: await resolveFonts(fonts),   },   {    title: metadata?.title || \"\",    description: metadata?.description || \"\",   }  ); };  export const createOgImageHandler = (metadata: OgImageMetadata): RequestHandler => {  return async () => {   try {    const res = await generateOgImage(metadata);    // If ImageResponse is already a Response-compatible object, return it directly.    return res;   } catch (error) {    console.error(\"Error generating OG image:\", error);    // Return a simple 500 on failure (customize if you like)    return new Response(\"Failed to generate OG image\", {     status: 500,     statusText: \"Failed to generate OG image\",    });   }  }; };  Svelte Component This component defines the visual layout of your Open Graph images. You can customize it as needed.  Create a file at src/lib/components/shadcn-og.svelte with the following content:    type Props = {   title: string;   description: string;  };  const { title, description }: Props = $props();                                       20     ? '64px'     : '80px'}; letterSpacing: '-0.04em'\"    {title}          {description} The Vite Plugin  This is the core build-time automation logic. It scans your routes for sveltekit.og.ts and programmatically writes the necessary +server.ts file next to it.  Create this file as vite-plugins/og-route-generator.ts:       We don't export this plugin directly from the main package; it's intended for you to copy into your own project.   import * as fs from 'node:fs/promises'; import * as path from 'node:path'; import type { Plugin, ViteDevServer } from 'vite';  const PLUGIN_NAME = 'vite-plugin-og-route-generator'; const CONFIG_FILE_PATTERN = /^sveltekit\\.og\\.(ts|js)$/; const SERVER_ROUTE_DIR = 'og.png'; const DEFAULT_ROUTES_DIR = 'src/routes'; const MANIFEST_FILE_PATH_STRING = '.svelte-kit/generated-og-images.json';  // Content to inject into the auto-generated +server.ts file function generateServerRouteContent(): string {   // Imports the metadata and calls the central handler   return `import { ogMetadata } from \"../sveltekit.og.js\"; import { createOgImageHandler } from \"$lib/og-image.js\"; export const prerender = true; export const GET = createOgImageHandler(ogMetadata);`; }  // Helper to clean up previously generated files async function initialCleanup(root: string): Promise {   // (Omitted cleanup logic for brevity, but this is critical for clean builds) }  // Helper to find all sveltekit.og.(ts|js) files async function discoverConfigFiles(root: string): Promise {   // (Omitted discovery logic for brevity)   return [];  }   async function generateRoutes(root: string): Promise {   const newManifest = { files: [], directories: [] };   const configFiles = await discoverConfigFiles(root);    for (const configFile of configFiles) {    const routeDir = path.dirname(configFile.fullPath);    const serverRouteFileName = +server${configFile.ext};     const newServerDirPath = path.join(routeDir, SERVER_ROUTE_DIR);    const newServerFilePath = path.join(newServerDirPath, serverRouteFileName);     // 1. Create the new directory (e.g., /about/og.png)    await fs.mkdir(newServerDirPath, { recursive: true });        // 2. Write the generated content    const content = generateServerRouteContent();    await fs.writeFile(newServerFilePath, content, 'utf-8');     console.log([${PLUGIN_NAME}] Generated route: ${path.relative(root, newServerFilePath)});    newManifest.files.push(newServerFilePath);    newManifest.directories.push(newServerDirPath);   }    // (Omitted manifest write logic for brevity) }  export function ogRouteGenerator(): Plugin {   let root = '';      return {    name: PLUGIN_NAME,        configResolved(resolvedConfig) { root = resolvedConfig.root; },     // Run generation at the start of the build process and on dev server startup    async buildStart() {     await initialCleanup(root);     await generateRoutes(root);    },        // Re-run on file changes for HMR (ViteDevServer required)    configureServer(server: ViteDevServer) {     // Logic to watch for changes in sveltekit.og.ts files and regenerate routes...     // (Omitted HMR logic for brevity)     initialCleanup(root).then(() => generateRoutes(root));    }   }; }  Vite Configuration Integrate the plugin into your Vite configuration. Reference the new custom plugin in your vite.config.js:  import { sveltekit } from '@sveltejs/kit/vite'; import { ogRouteGenerator } from './vite-plugins/og-route-generator.js'; import { sveltekitOG } from \"@ethercorps/sveltekit-og/plugin\"; import { defineConfig } from 'vite';  export default defineConfig({  plugins: [   sveltekit(),         sveltekitOG(),   // ... other plugins   ogRouteGenerator() // Add your custom plugin  ] });  Usage and Result  The core idea is that the sveltekit.og.ts file acts as the configuration layer for the OG image's props, and the generated +server.ts file automatically imports and uses that configuration.  Configuration File  For any page you want an OG image for, create the configuration file (sveltekit.og.ts) and export the ogMetadata object. This object must contain the props for your Svelte component expects like title, description, and any other props.  // This file acts as the configuration layer, defining the image's props.  /**  The 'ogMetadata' object is exported and its properties are used directly  as props for the ShadcnOG Svelte component.  */ export const ogMetadata = {     title: \"About SvelteKit OG and Our Team\",     description: \"Learn about the mission, the architecture, and the contributors to this project.\",     // You could add other custom props here if your Svelte component accepts them:     // icon: 'gear', };  Generated Route  When you run vite dev or npm run build, the plugin automatically creates the endpoint, making the OG image accessible (e.g., at /about/og.png).  The key line here is the import: import { ogMetadata } from \"../sveltekit.og.js\";  import { ogMetadata } from \"../sveltekit.og.js\";  import { createOgImageHandler } from \"$lib/og-image.js\"; export const prerender = true; // 2. Passes the imported ogMetadata directly to the generic handler export const GET = createOgImageHandler(ogMetadata);  Customization  Vite plugin code is provided as a starting point. You can extend it to fit your project's needs, such as adding more sophisticated error handling, logging, or supporting additional configuration options. Which means you can easily change code generated in the +server.ts files to suit your architecture.  import { ogMetadata } from \"../sveltekit.og.js\"; import { createOgImageHandler } from \"$lib/og-image.js\"; export const prerender = true; export const GET = createOgImageHandler(ogMetadata); You can change the import paths if your project structure differs (e.g $lib/og-image.js). You can modify how the ogMetadata is passed to the handler if you want to preprocess or validate it before use. You can add additional exports or middleware logic in the generated +server.ts files as needed.  Conclusion By following this guide, you can automate the creation of Open Graph image routes in your SvelteKit project using a custom Vite plugin. This approach minimizes boilerplate and ensures consistency across your OG image endpoints, making it easier to manage and scale your application's social media presence."
	},
	{
		"title": "GitHub Repository OG Image",
		"href": "/docs/examples/github-repo-og",
		"description": "Recreate the iconic GitHub repository social card using dynamic data and Svelte components.",
		"content": "import { Callout, DemoContainer, Tabs, TabItem } from \"@svecodocs/kit\";     import SvelteComponentPlayground from \"$lib/components/playground/svelte-component.svelte\";     import { page } from \"$app/state\";   const serverFiles = [\"github-repo.svelte\", \"+server.ts\", \"api.ts\", \"fonts-utils.ts\"];     const tabHashMapping = {       \"#the-visual-component\": \"github-repo.svelte\",       \"#the-api-route\": \"+server.ts\",       \"#data-fetching-helper\": \"api.ts\",       \"#fonts-config\": \"fonts-utils.ts\"     };            const currentTab = $derived(tabHashMapping[page.url.hash] || 'github-repo.svelte');  Overview  In this example, we will recreate the iconic GitHub repository Open Graph image. This involves: Fetching live data from the GitHub API. Loading custom fonts (Inter) to match the brand. Rendering a Svelte component that visually mimics the design.  Target Design:  Code Implementation  The Visual Component  Svelte component handles the layout. It receives data via props and uses Tailwind classes (via class attribute) for styling.  The API Route  Server endpoint ties everything together. It handles the request, fetches the data, loads the fonts, and returns the generated image.  Data Fetching Helper  A simple utility to fetch repository details (stars, forks, issues) from the GitHub API.  Fonts Config  To get the authentic look, we load the Inter font family (Regular and Bold) using Google Fonts.  Live Preview  Start your development server and visit the URL below. Change the owner and repo query parameters to generate cards for different repositories instantly in $2.  Playground  Experiment with the component props directly in the browser:"
	},
	{
		"title": "Pre-render OG images for docs",
		"href": "/docs/examples/pre-render",
		"description": "Guide to pre-rendering Open Graph images for documentation app (svecodocs).",
		"content": "This example demonstrates how to implement highly efficient, pre-rendered Open Graph images for a documentation site (like $2). We use a complex component design with nested logic, custom fonts, and SvelteKit's built-in prerender feature.  File Structure  This structure nests the image endpoint directly within the documentation route (/docs/doc/[...slug]), resulting in clean URLs for OG image like /docs/components/button/og.png.  /src â”œâ”€â”€ /lib â”‚   â”œâ”€â”€ /utils â”‚   â”‚   â””â”€â”€ docs.ts         import type { SVGAttributes } from 'svelte/elements';   export type Attrs = SVGAttributes;    type Props = {    class?: string;    color?: string;    size?: number;    strokeWidth?: number;    absoluteStrokeWidth?: boolean;    startColor?: string;    endColor?: string;   }    const { class: className, color = 'currentColor', size = 140, strokeWidth = 2, absoluteStrokeWidth = false, startColor=\"#FC7421\", endColor=\"#FEBC5A\", ...props }: Attrs & Props = $props();  OG Image Component This component receives the title and description from the server and dynamically adjusts the font size based on the title length for optimal display.     import LogoIcon from \"./logo-icon.svelte\";    type Props = {    title: string    description: string   }    const {title, description}: Props = $props()                                       20 ? '64px' : '80px'}; letterSpacing: '-0.04em'\"     {title}             {description} Server Endpoint The server endpoint imports all documentation metadata, matches the requested slug to find the relevant title and description, and pre-renders the OG image using the ImageResponse class.  import type { RequestHandler } from '@sveltejs/kit'; import { ImageResponse } from '@ethercorps/sveltekit-og'; import { GoogleFont, resolveFonts } from '@ethercorps/sveltekit-og/fonts'; import OgComponent from \"$lib/components/og.svelte\"; // The main component import type { EntryGenerator } from './$types'; import { getAllDocs, getDocMetadata } from '$lib/utils/docs.js'; // Data utility imports  // 1. Define the fonts to load const fonts = [   // These fonts will be fetched and cached globally   new GoogleFont('Geist', {weight: 400}),   new GoogleFont('Geist', {weight: 600}),   new GoogleFont('Geist Mono', {weight: 400}), ]  // 2. Enable prerendering export const prerender = true;  /**  entryGenerator: Tells SvelteKit which documentation pages need an image built.  It iterates over all documentation files found by the data utility.  */ export const entries: EntryGenerator = async () => {   // Use data utility to retrieve all slugs   return getAllDocs().map((doc) => ({    // The slug must be in the format required by the route's dynamic segment    slug: doc.slug,   })); };  export const GET: RequestHandler = async ({params}) => {   // 3. Fetch the specific metadata for the current slug   const metadata = getDocMetadata(params.slug)      // Handle 404/Missing Data   if (!metadata) {       return new Response(null, { status: 404 });   }      // 4. Resolve the fonts (cache will be hit after the first run)   const resolvedFonts = await resolveFonts(fonts)      // 5. Return the ImageResponse   return new ImageResponse(    OgComponent,    {     height: 630,     width: 1200,     fonts: resolvedFonts,     // Aggressive Caching for static built files     headers: {         'Cache-Control': 'public, immutable, max-age=31536000'     }    },    {     // Pass dynamic data to the Svelte component's props     title: metadata.title || 'Sveltekit OG',     description: metadata.description || 'Dynamic OG, easy...'    }) }  Now, when you build your SvelteKit app, OG images for each documentation page will be pre-rendered and saved as static images, ensuring fast load times and reduced server overhead."
	},
	{
		"title": "Fonts",
		"href": "/docs/utilities/fonts",
		"description": "How to use self hosted, custom and google fonts with sveltekit-og.",
		"content": "import { Callout } from \"@svecodocs/kit\";     The GoogleFont, CustomFont, and resolveFonts utilities were introduced in  sveltekit-og@v4.2.0.    To ensure consistent and high-quality typography in your generated images, you must provide the font files to the rendering engine (Satori) as raw binary data. You cannot rely on standard CSS @font-face rules.  The SvelteKit OG provides CustomFont, and GoogleFont classes, along with the resolveFonts utility, to handle loading, caching, and preparing the font data.    The ImageResponse options expects an array of resolved font data. You must always pass your font instances to await resolveFonts([...]) before passing the result to the fonts option.  ðŸŒ Using Google Fonts  The GoogleFont class is the easiest way to get started. It abstracts away the network logic, fetches the correct CSS, parses the font URL, and applies an internal cache to prevent redundant requests.  import { ImageResponse } from '@ethercorps/sveltekit-og'; import { GoogleFont, resolveFonts } from '@ethercorps/sveltekit-og/fonts';  // 1. Define the GoogleFont instances const interRegular = new GoogleFont('Inter', {  weight: 400,  name: 'Inter', });  const interBold = new GoogleFont('Inter', {  weight: 700 });  export const GET = async () => {  // 2. Await the resolution (which triggers the fetch/cache lookup)  const resolvedFontOptions = await resolveFonts([interRegular, interBold]);   return new ImageResponse(   Hello World,   {    fonts: resolvedFontOptions   }  ); };  ðŸ“‚ Using Local Custom Fonts  This method involves placing TrueType (.ttf) or OpenType (.otf) files in the project and reading them directly from the file system.  Steps Import: Use the Vite ?url suffix to get the build-time path of your local font file. Load: Use SvelteKit's $app/server read function to retrieve the file. Wrap: Pass a function that returns the ArrayBuffer to CustomFont.    Vite's ?url import combined with read may encounter issues on specific adapters like Netlify. In those cases, you may need to use Node's fs module or fetch the font from a public URL.    import { ImageResponse } from '@ethercorps/sveltekit-og'; import { CustomFont, resolveFonts } from '@ethercorps/sveltekit-og/fonts'; import { read } from '$app/server'; // SvelteKit Runtime Dependency import RegularFontPath from '$lib/assets/MyFont-Regular.ttf?url'; import BoldFontPath from '$lib/assets/MyFont-Bold.ttf?url';  // 1. Define the CustomFont instances const myCustomRegular = new CustomFont(  'My Custom Font',  // The input function executes read().arrayBuffer() only when needed (lazy-loaded)  () => read(RegularFontPath).arrayBuffer(),  { weight: 400 } );  const myCustomBold = new CustomFont(  'My Custom Font',  () => read(BoldFontPath).arrayBuffer(),  { weight: 700 } );  export const GET = async () => {  // 2. Resolve the promises to get the final ArrayBuffer array  const resolvedFontOptions = await resolveFonts([myCustomRegular, myCustomBold]);   return new ImageResponse(   Hello World,   {    width: 1200,    height: 630,    fonts: resolvedFontOptions   }  ); };  â˜ï¸ Using Remote Fonts  If font file is hosted on an external CDN (e.g., AWS S3, generic file host), fetch it directly using the global fetch API.  import { ImageResponse } from '@ethercorps/sveltekit-og'; import { CustomFont, resolveFonts } from '@ethercorps/sveltekit-og/fonts';  const REMOTE_FONT_URL = 'https://my-cdn.com/assets/FontAwesome-Regular.otf';  // 1. Define the CustomFont instance const fontAwesome = new CustomFont(  'Font Awesome',  // Pass a function that returns the ArrayBuffer promise via fetch  () => fetch(REMOTE_FONT_URL).then((res) => res.arrayBuffer()),  { weight: 400 } );  export const GET = async () => {  const resolvedFontOptions = await resolveFonts([fontAwesome]);   return new ImageResponse(   Icon,   {    fonts: resolvedFontOptions   }  ); };  ðŸ”¢ Multiple Font Sources  Mix and match multiple font sources local fonts, Google Fonts, and remote fonts URLs in a single request.  import { ImageResponse } from '@ethercorps/sveltekit-og'; import { CustomFont, GoogleFont, resolveFonts } from '@ethercorps/sveltekit-og/fonts'; import { read } from '$app/server';  // --- Local Font Paths --- import LocalRegularPath from '$lib/assets/LocalFont-R.ttf?url';  // --- Custom Remote URL --- const ICON_FONT_URL = 'https://cdn.example.com/icons.ttf';  export const GET = async () => {  // 1. Define all font instances  const fontsToLoad = [   // A. ðŸ“¦ LOCAL CUSTOM FONT   new CustomFont('Local App Font', () => read(LocalRegularPath).arrayBuffer(), { weight: 400 }),    // B. ðŸŒ GOOGLE FONT   new GoogleFont('Roboto Mono', { weight: 500 }),    // C. â˜ï¸ REMOTE FONT   new CustomFont('Custom Icons', () => fetch(ICON_FONT_URL).then((res) => res.arrayBuffer()), {    weight: 400   })  ];   // 2. Resolve all concurrently  const resolvedFontOptions = await resolveFonts(fontsToLoad);   // 3. Render  return new ImageResponse(   `             Title             Code             Icon         `,   {    width: 1200,    height: 630,    fonts: resolvedFontOptions   }  ); }; `"
	},
	{
		"title": "ImageResponse API Reference",
		"href": "/docs/utilities/types",
		"description": "Reference for the ImageResponse constructor and its options.",
		"content": "import {Callout, PropField, Collapsible, blockquote} from '@svecodocs/kit';  ImageResponse  The ImageResponse class is the central API for generating and serving dynamic images. It extends the standard Web API Response and is designed to be returned directly from a SvelteKit server route (+server.ts).  The constructor takes the component/HTML template, rendering options, and component props.  new ImageResponse>(  element: T,  options?: ImageResponseOptions,  props?: T extends Component ? ComponentProps : never ): Response;  ImageResponse Parameters  To create your dynamic Open Graph image, the ImageResponse constructor needs just three pieces of information, passed in this specific order. Think of this as defining the design, the settings, and the data for your image. Svelte Component or Raw HTML: The design of your imageâ€”what people will actually see. Options: The settings that define the image's size, fonts, and response headers. Props: The dynamic data (like a blog post title) to feed into your Svelte component.  import { ImageResponse } from '@ethercorps/sveltekit-og'; import { CustomFont, resolveFonts } from '@ethercorps/sveltekit-og/fonts'; import MySvelteComponent from '$lib/og/MySvelteComponent.svelte'; export const GET = async () => {     const props = {         title: 'Dynamic Title',         subtitle: 'Generated with Sveltekit OG'     };  const fonts = [   new CustomFont('Inter', () => fetch('https://example.com/fonts/Inter-Regular.ttf').then(res => res.arrayBuffer()), {weight: '400'})     ]      return new ImageResponse(   // 1. Svelte Component or Raw HTML          MySvelteComponent,         // 2. Options         {             width: 1200,             height: 630,             fonts: await resolveFonts(fonts)         },         // 3. Svelte Component props         props     ); };    Font files must be loaded as raw binary data (ArrayBuffer). The GoogleFont, CustomFont and resolveFonts $2 are provided to help you asynchronously load your custom fonts correctly before the image is generated.  Svelte Component or HTML  This parameter defines the visual content of your Open Graph image. You can provide either a Svelte component or a raw HTML string.          While you can use raw HTML, using a Svelte component is recommended for better maintainability and reusability.  ImageResponse Options The options object allows you to customize various technical aspects of the generated image and its HTTP response.       Configuration options for the generated image and its response.                        Sets the width of the final OG image in pixels.                             Sets the height of the final OG image in pixels.                              The file format for the generated image. PNG is standard for OG images, but SVG is also available.                               A list of font definitions (name, data, weight) used to render text in your design.                                                   The font file data loaded as a Buffer or ArrayBuffer.                                                       The font family name (must match your CSS font-family).                                                       The weight of the font (e.g., 400 for regular, 700 for bold).                                                       The style of the font.                                                       The language subset for the font (e.g., 'en').                                                             Choose the style of emojis you want to use in your design (e.g., Twitter's Twemoji is the default).                               Turn this on to show helpful layout guides and rulers on the image. Great for troubleshooting positioning!                               The HTTP status code sent with the image (e.g., 200 for success).                               The HTTP status text sent alongside the status code.                  \" >             Add any custom HTTP headers you need for the response.                                        We automatically add Content-Type based on the image format and Cache-Control for caching. If debug mode is enabled, the Cache-Control header is updated to no-cache.  Component Props  \" >     An object containing the dynamic data to be passed to your Svelte component (the first parameter). If your component expects a title or author, you pass it here!                   This parameter is required if you use a Svelte component that expects props.  The types for this object are automatically inferred from the props defined in your Svelte component.  All Options Example  Here is an example demonstrating how to use several optional parameters, including setting custom headers and enabling debug mode.  import { ImageResponse } from '@ethercorps/sveltekit-og'; import { resolveFonts } from '@ethercorps/sveltekit-og/fonts'; import MySvelteComponent from '$lib/og/MySvelteComponent.svelte'; import { FONT_DATA } from '$lib/fonts'; // Assume pre-loaded font data  export const GET = async ({ url }) => {     // 1. Prepare dynamic data     const isError = url.searchParams.has('error');          // 2. Define custom options     const options = {         width: 1200,         height: 630,         debug: url.searchParams.has('debug'), // Toggle debug mode via query param         emoji: 'blobmoji', // Use a different emoji set         fonts: await resolveFonts(FONT_DATA),                  // 3. Conditional HTTP Response options         status: isError ? 404 : 200,         statusText: isError ? 'Not Found' : 'OK',         headers: {             // Override or add custom headers             'X-OG-Generator': '@ethercorps/sveltekit-og',         }     };          // 4. Define component props     const props = {         title: isError ? 'Page Not Found' : 'Standard Post Title',     };      return new ImageResponse(MySvelteComponent, options, props); };        resolveFonts can only be used with GoogleFont and CustomFont instances."
	}
]
